<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 8. Key-Value Databases</title>
<link href="9780133036121.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:612fcd70-0110-46e1-b1de-b4c342e334cd"/>
</head>
<body>
<h2 id="ch08"><a id="page_81"/>Chapter 8. Key-Value Databases</h2>
<p class="noindent">A key-value store is a simple hash table, primarily used when all access to the database is via primary key. Think of a table in a traditional RDBMS with two columns, such as <code>ID</code> and <code>NAME</code>, the <code>ID</code> column being the key and <code>NAME</code> column storing the value. In an RDBMS, the <code>NAME</code> column is restricted to storing data of type <code>String</code>. The application can provide an <code>ID</code> and <code>VALUE</code> and persist the pair; if the <code>ID</code> already exists the current value is overwritten, otherwise a new entry is created. Let’s look at how terminology compares in Oracle and Riak.</p>
<div class="image"><img alt="Image" src="graphics/08tab01.jpg"/></div>
<h3 id="ch08lev1sec1">8.1. What Is a Key-Value Store</h3>
<p class="noindent">Key-value stores are the simplest NoSQL data stores to use from an API perspective. The client can either get the value for the key, put a value for a key, or delete a key from the data store. The value is a blob that the data store just stores, without caring or knowing what’s inside; it’s the responsibility of the application to understand what was stored. Since key-value stores always use primary-key access, they generally have great performance and can be easily scaled.</p>
<p class="indent">Some of the popular key-value databases are Riak <a href="bib01.html#bib_61">[Riak]</a>, Redis (often referred to as Data Structure server) <a href="bib01.html#bib_59">[Redis]</a>, Memcached DB and its flavors <a href="bib01.html#bib_43">[Memcached]</a>, Berkeley DB <a href="bib01.html#bib_06">[Berkeley DB]</a>, HamsterDB (especially suited for embedded use) <a id="page_82"/><a href="bib01.html#bib_30">[HamsterDB]</a>, Amazon DynamoDB <a href="bib01.html#bib_02">[Amazon’s Dynamo]</a> (not open-source), and Project Voldemort <a href="bib01.html#bib_57">[Project Voldemort]</a> (an open-source implementation of Amazon DynamoDB).</p>
<p class="indent">In some key-value stores, such as Redis, the aggregate being stored does not have to be a domain object—it could be any data structure. Redis supports storing <code>lists</code>, <code>sets</code>, <code>hashes</code> and can do range, diff, union, and intersection operations. These features allow Redis to be used in more different ways than a standard key-value store.</p>
<p class="indent">There are many more key-value databases and many new ones are being worked on at this time. For the sake of keeping discussions in this book easier we will focus mostly on Riak. Riak lets us store keys into buckets, which are just a way to segment the keys—think of buckets as flat namespaces for the keys.</p>
<p class="indent">If we wanted to store user session data, shopping cart information, and user preferences in Riak, we could just store all of them in the same bucket with a single key and single value for all of these objects. In this scenario, we would have a single object that stores all the data and is put into a single bucket (<a href="#ch08fig01">Figure 8.1</a>).</p>
<div class="image"><a id="ch08fig01"/><img alt="Image" height="405" src="graphics/08fig01.jpg" width="250"/></div>
<p class="fig-caption">Figure 8.1. Storing all the data in a single bucket</p>
<p class="indent">The downside of storing all the different objects (aggregates) in the single bucket would be that one bucket would store different types of aggregates, increasing the chance of key conflicts. An alternate approach would be to append the name of the object to the key, such as <code>288790b8a421_userProfile</code>, so that we can get to individual objects as they are needed (<a href="#ch08fig02">Figure 8.2</a>).</p>
<div class="image"><a id="page_83"/><a id="ch08fig02"/><img alt="Image" src="graphics/08fig02.jpg"/></div>
<p class="fig-caption">Figure 8.2. Change the key design to segment the data in a single bucket.</p>
<p class="indent">We could also create buckets which store specific data. In Riak, they are known as <strong>domain buckets</strong> allowing the serialization and deserialization to be handled by the client driver.</p>
<p class="codelink"><a href="images.html#p0103_01" id="p0103_01a">Click here to view code image</a></p>
<p class="programlisting">Bucket bucket = client.fetchBucket(bucketName).execute();<br/>DomainBucket&lt;UserProfile&gt; profileBucket =<br/>DomainBucket.builder(bucket, UserProfile.class).build();</p>
<p class="indent">Using domain buckets or different buckets for different objects (such as <code>UserProfile</code> and <code>ShoppingCart</code>) segments the data across different buckets allowing you to read only the object you need without having to change key design.</p>
<p class="indent">Key-value stores such as Redis also support storing random data structures, which can be sets, hashes, strings, and so on. This feature can be used to store lists of things, like <code>states</code> or <code>addressTypes</code>, or an array of user’s visits.</p>
<h3 id="ch08lev1sec2">8.2. Key-Value Store Features</h3>
<p class="noindent">While using any NoSQL data stores, there is an inevitable need to understand how the features compare to the standard RDBMS data stores that we are so used to. The primary reason is to understand what features are missing and how does the application architecture need to change to better use the features of a key-value data store. Some of the features we will discuss for all the NoSQL data stores are consistency, transactions, query features, structure of the data, and scaling.</p>
<h4 id="ch08lev2sec1">8.2.1. Consistency</h4>
<p class="noindent">Consistency is applicable only for operations on a single key, since these operations are either a get, put, or delete on a single key. Optimistic writes can be performed, but are very expensive to implement, because a change in value cannot be determined by the data store.</p>
<p class="indent">In distributed key-value store implementations like Riak, the <em>eventually consistent</em> (p. <a href="ch05.html#page_50">50</a>) model of consistency is implemented. Since the value may have already <a id="page_84"/>been replicated to other nodes, Riak has two ways of resolving update conflicts: either the newest write wins and older writes loose, or both (all) values are returned allowing the client to resolve the conflict.</p>
<p class="indent">In Riak, these options can be set up during the bucket creation. Buckets are just a way to namespace keys so that key collisions can be reduced—for example, all customer keys may reside in the <code>customer</code> bucket. When creating a bucket, default values for consistency can be provided, for example that a write is considered good only when the data is consistent across all the nodes where the data is stored.</p>
<p class="codelink"><a href="images.html#p0104_01" id="p0104_01a">Click here to view code image</a></p>
<p class="programlisting">Bucket bucket = connection<br/>    .createBucket(bucketName)<br/>    .withRetrier(attempts(3))<br/>    .allowSiblings(siblingsAllowed)<br/>    .nVal(numberOfReplicasOfTheData)<br/>    .w(numberOfNodesToRespondToWrite)<br/>    .r(numberOfNodesToRespondToRead)<br/>    .execute();</p>
<p class="indent">If we need data in every node to be consistent, we can increase the <code>numberOfNodesToRespondToWrite</code> set by <code>w</code> to be the same as <code>nVal</code>. Of course doing that will decrease the write performance of the cluster. To improve on write or read conflicts, we can change the <code>allowSiblings</code> flag during bucket creation: If it is set to false, we let the last write to win and not create siblings.</p>
<h4 id="ch08lev2sec2">8.2.2. Transactions</h4>
<p class="noindent">Different products of the key-value store kind have different specifications of transactions. Generally speaking, there are no guarantees on the writes. Many data stores do implement transactions in different ways. Riak uses the concept of quorum (“<a href="ch05.html#ch05lev1sec5">Quorums</a>,” p. <a href="ch05.html#page_57">57</a>) implemented by using the <code>W</code> value—replication factor—during the write API call.</p>
<p class="indent">Assume we have a Riak cluster with a replication factor of 5 and we supply the <code>W</code> value of <code>3</code>. When writing, the write is reported as successful only when it is written and reported as a success on at least three of the nodes. This allows Riak to have write tolerance; in our example, with <code>N</code> equal to <code>5</code> and with a <code>W</code> value of <code>3</code>, the cluster can tolerate <code>N - W = 2</code> nodes being down for write operations, though we would still have lost some data on those nodes for read.</p>
<h4 id="ch08lev2sec3">8.2.3. Query Features</h4>
<p class="noindent">All key-value stores can query by the key—and that’s about it. If you have requirements to query by using some attribute of the value column, it’s not possible to use the database: Your application needs to read the value to figure out if the attribute meets the conditions.</p>
<p class="indent"><a id="page_85"/>Query by key also has an interesting side effect. What if we don’t know the key, especially during ad-hoc querying during debugging? Most of the data stores will not give you a list of all the primary keys; even if they did, retrieving lists of keys and then querying for the value would be very cumbersome. Some key-value databases get around this by providing the ability to search inside the value, such as <strong>Riak Search</strong> that allows you to query the data just like you would query it using Lucene indexes.</p>
<p class="indent">While using key-value stores, lots of thought has to be given to the design of the key. Can the key be generated using some algorithm? Can the key be provided by the user (user ID, email, etc.)? Or derived from timestamps or other data that can be derived outside of the database?</p>
<p class="indent">These query characteristics make key-value stores likely candidates for storing session data (with the session ID as the key), shopping cart data, user profiles, and so on. The <code>expiry_secs</code> property can be used to expire keys after a certain time interval, especially for session/shopping cart objects.</p>
<p class="codelink"><a href="images.html#p0105_01" id="p0105_01a">Click here to view code image</a></p>
<p class="programlisting">Bucket bucket = getBucket(bucketName);<br/>IRiakObject riakObject = bucket.store(key, value).execute();</p>
<p class="indent">When writing to the Riak bucket using the <code>store</code> API, the object is stored for the key provided. Similarly, we can get the value stored for the key using the <code>fetch</code> API.</p>
<p class="codelink"><a href="images.html#p0105_02" id="p0105_02a">Click here to view code image</a></p>
<p class="programlisting">Bucket bucket = getBucket(bucketName);<br/>IRiakObject riakObject = bucket.fetch(key).execute();<br/>byte[] bytes = riakObject.getValue();<br/>String value = new String(bytes);</p>
<p class="indent">Riak provides an HTTP-based interface, so that all operations can be performed from the web browser or on the command line using <code>curl</code>. Let’s save this data to Riak:</p>
<p class="codelink"><a href="images.html#p0105_03" id="p0105_03a">Click here to view code image</a></p>
<p class="programlisting">{<br/>"lastVisit":1324669989288,<br/>"user":{<br/>  "customerId":"91cfdf5bcb7c",<br/>  "name":"buyer",<br/>  "countryCode":"US",<br/>  "tzOffset":0<br/>  }<br/>}</p>
<p class="indent">Use the <code>curl</code> command to <code>POST</code> the data, storing the data in the <code>session</code> bucket with the key of <code>a7e618d9db25</code> (we have to provide this key):</p>
<p class="codelink"><a href="images.html#p0106_01" id="p0106_01a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_86"/>curl -v -X POST -d '<br/>{ "lastVisit":1324669989288,<br/>  "user":{"customerId":"91cfdf5bcb7c",<br/>  "name":"buyer",<br/>  "countryCode":"US",<br/>  "tzOffset":0}<br/>}'<br/>-H "Content-Type: application/json"<br/>http://localhost:8098/buckets/session/keys/a7e618d9db25</p>
<p class="indent">The data for the key <code>a7e618d9db25</code> can be fetched by using the <code>curl</code> command:</p>
<p class="codelink"><a href="images.html#p0106_02" id="p0106_02a">Click here to view code image</a></p>
<p class="programlisting">curl -i http://localhost:8098/buckets/session/keys/a7e618d9db25</p>
<h4 id="ch08lev2sec4">8.2.4. Structure of Data</h4>
<p class="noindent">Key-value databases don’t care what is stored in the value part of the key-value pair. The value can be a blob, text, JSON, XML, and so on. In Riak, we can use the <code>Content-Type</code> in the <code>POST</code> request to specify the data type.</p>
<h4 id="ch08lev2sec5">8.2.5. Scaling</h4>
<p class="noindent">Many key-value stores scale by using sharding (“<a href="ch04.html#ch04lev1sec2">Sharding</a>,” p. <a href="ch04.html#page_38">38</a>). With sharding, the value of the key determines on which node the key is stored. Let’s assume we are sharding by the first character of the key; if the key is <code>f4b19d79587d</code>, which starts with an <code>f</code>, it will be sent to different node than the key <code>ad9c7a396542</code>. This kind of sharding setup can increase performance as more nodes are added to the cluster.</p>
<p class="indent">Sharding also introduces some problems. If the node used to store <code>f</code> goes down, the data stored on that node becomes unavailable, nor can new data be written with keys that start with <code>f</code>.</p>
<p class="indent">Data stores such as Riak allow you to control the aspects of the CAP Theorem (“<a href="ch05.html#ch05lev2sec1">The CAP Theorem</a>,” p. <a href="ch05.html#page_53">53</a>): <code>N</code> (number of nodes to store the key-value replicas), <code>R</code> (number of nodes that have to have the data being fetched before the read is considered successful), and <code>W</code> (the number of nodes the write has to be written to before it is considered successful).</p>
<p class="indent">Let’s assume we have a 5-node Riak cluster. Setting <code>N</code> to <code>3</code> means that all data is replicated to at least three nodes, setting <code>R</code> to <code>2</code> means any two nodes must reply to a <code>GET</code> request for it to be considered successful, and setting <code>W</code> to <code>2</code> ensures that the <code>PUT</code> request is written to two nodes before the write is considered successful.</p>
<p class="indent">These settings allow us to fine-tune node failures for read or write operations. Based on our need, we can change these values for better read availability or write availability. Generally speaking choose a <code>W</code> value to match your consistency needs; these values can be set as defaults during bucket creation.</p>
<h3 id="ch08lev1sec3"><a id="page_87"/>8.3. Suitable Use Cases</h3>
<p class="noindent">Let’s discuss some of the problems where key-value stores are a good fit.</p>
<h4 id="ch08lev2sec6">8.3.1. Storing Session Information</h4>
<p class="noindent">Generally, every web session is unique and is assigned a unique <code>sessionid</code> value. Applications that store the <code>sessionid</code> on disk or in an RDBMS will greatly benefit from moving to a key-value store, since everything about the session can be stored by a single <code>PUT</code> request or retrieved using <code>GET</code>. This single-request operation makes it very fast, as everything about the session is stored in a single object. Solutions such as Memcached are used by many web applications, and Riak can be used when availability is important.</p>
<h4 id="ch08lev2sec7">8.3.2. User Profiles, Preferences</h4>
<p class="noindent">Almost every user has a unique <code>userId</code>, <code>username</code>, or some other attribute, as well as preferences such as language, color, timezone, which products the user has access to, and so on. This can all be put into an object, so getting preferences of a user takes a single <code>GET</code> operation. Similarly, product profiles can be stored.</p>
<h4 id="ch08lev2sec8">8.3.3. Shopping Cart Data</h4>
<p class="noindent">E-commerce websites have shopping carts tied to the user. As we want the shopping carts to be available all the time, across browsers, machines, and sessions, all the shopping information can be put into the <code>value</code> where the key is the <code>userid</code>. A Riak cluster would be best suited for these kinds of applications.</p>
<h3 id="ch08lev1sec4">8.4. When Not to Use</h3>
<p class="noindent">There are problem spaces where key-value stores are not the best solution.</p>
<h4 id="ch08lev2sec9">8.4.1. Relationships among Data</h4>
<p class="noindent">If you need to have relationships between different sets of data, or correlate the data between different sets of keys, key-value stores are not the best solution to use, even though some key-value stores provide link-walking features.</p>
<h4 id="ch08lev2sec10"><a id="page_88"/>8.4.2. Multioperation Transactions</h4>
<p class="noindent">If you’re saving multiple keys and there is a failure to save any one of them, and you want to revert or roll back the rest of the operations, key-value stores are not the best solution to be used.</p>
<h4 id="ch08lev2sec11">8.4.3. Query by Data</h4>
<p class="noindent">If you need to search the keys based on something found in the value part of the key-value pairs, then key-value stores are not going to perform well for you. There is no way to inspect the value on the database side, with the exception of some products like Riak Search or indexing engines like Lucene <a href="bib01.html#bib_41">[Lucene]</a> or Solr <a href="bib01.html#bib_62">[Solr]</a>.</p>
<h4 id="ch08lev2sec12">8.4.4. Operations by Sets</h4>
<p class="noindent">Since operations are limited to one key at a time, there is no way to operate upon multiple keys at the same time. If you need to operate upon multiple keys, you have to handle this from the client side.</p>
</body>
</html>