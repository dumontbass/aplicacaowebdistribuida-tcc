<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 9. Document Databases</title>
<link href="9780133036121.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:612fcd70-0110-46e1-b1de-b4c342e334cd"/>
</head>
<body>
<h2 id="ch09"><a id="page_89"/>Chapter 9. Document Databases</h2>
<p class="noindent">Documents are the main concept in document databases. The database stores and retrieves documents, which can be XML, JSON, BSON, and so on. These documents are self-describing, hierarchical tree data structures which can consist of maps, collections, and scalar values. The documents stored are similar to each other but do not have to be exactly the same. Document databases store documents in the value part of the key-value store; think about document databases as key-value stores where the value is examinable. Let’s look at how terminology compares in Oracle and MongoDB.</p>
<div class="image"><img alt="Image" src="graphics/09tab01.jpg"/></div>
<p class="indent">The <code>_id</code> is a special field that is found on all documents in Mongo, just like <code>ROWID</code> in Oracle. In MongoDB, <code>_id</code> can be assigned by the user, as long as it is unique.</p>
<h3 id="ch09lev1sec1"><a id="page_90"/>9.1. What Is a Document Database?</h3>
<p class="codelink"><a href="images.html#p0110_01" id="p0110_01a">Click here to view code image</a></p>
<p class="programlisting">{ "firstname": "Martin",<br/>  "likes": [ "Biking",<br/>             "Photography" ],<br/>  "lastcity": "Boston",<br/>  "lastVisited":<br/>}</p>
<p class="indent">The above document can be considered a row in a traditional RDBMS. Let’s look at another document:</p>
<p class="codelink"><a href="images.html#p0110_02" id="p0110_02a">Click here to view code image</a></p>
<p class="programlisting">{<br/>  "firstname": "Pramod",<br/>  "citiesvisited": [ "Chicago", "London", "Pune", "Bangalore" ],<br/>  "addresses": [<br/>    { "state": "AK",<br/>      "city": "DILLINGHAM",<br/>      "type": "R"<br/>    },<br/>    { "state": "MH",<br/>      "city": "PUNE",<br/>      "type": "R" }<br/>  ],<br/>  "lastcity": "Chicago"<br/>}</p>
<p class="indent">Looking at the documents, we can see that they are similar, but have differences in attribute names. This is allowed in document databases. The schema of the data can differ across documents, but these documents can still belong to the same collection—unlike an RDBMS where every row in a table has to follow the same schema. We represent a list of <code>citiesvisited</code> as an array, or a list of <code>addresses</code> as list of documents embedded inside the main document. Embedding child documents as subobjects inside documents provides for easy access and better performance.</p>
<p class="indent">If you look at the documents, you will see that some of the attributes are similar, such as <code>firstname</code> or <code>city</code>. At the same time, there are attributes in the second document which do not exist in the first document, such as <code>addresses</code>, while <code>likes</code> is in the first document but not the second.</p>
<p class="indent">This different representation of data is not the same as in RDBMS where every column has to be defined, and if it does not have data it is marked as empty or set to <code>null</code>. In documents, there are no empty attributes; if a given attribute is not found, we assume that it was not set or not relevant to the document. Documents allow for new attributes to be created without the need to define them or to change the existing documents.</p>
<p class="indent"><a id="page_91"/>Some of the popular document databases we have seen are MongoDB <a href="bib01.html#bib_44">[MongoDB]</a>, CouchDB <a href="bib01.html#bib_12">[CouchDB]</a>, Terrastore <a href="bib01.html#bib_65">[Terrastore]</a>, OrientDB <a href="bib01.html#bib_52">[OrientDB]</a>, RavenDB <a href="bib01.html#bib_58">[RavenDB]</a>, and of course the well-known and often reviled Lotus Notes <a href="bib01.html#bib_50">[Notes Storage Facility]</a> that uses document storage.</p>
<h3 id="ch09lev1sec2">9.2. Features</h3>
<p class="noindent">While there are many specialized document databases, we will use MongoDB as a representative of the feature set. Keep in mind that each product has some features that may not be found in other document databases.</p>
<p class="indent">Let’s take some time to understand how MongoDB works. Each MongoDB instance has multiple <em>databases</em>, and each database can have multiple <em>collections</em>. When we compare this with RDBMS, an RDBMS instance is the same as MongoDB instance, the schemas in RDBMS are similar to MongoDB databases, and the RDBMS tables are collections in MongoDB. When we store a document, we have to choose which database and collection this document belongs in—for example, <code>database.collection.insert(document)</code>, which is usually represented as <code>db.coll.insert(document)</code>.</p>
<h4 id="ch09lev2sec1">9.2.1. Consistency</h4>
<p class="noindent">Consistency in MongoDB database is configured by using the <strong>replica sets</strong> and choosing to wait for the writes to be replicated to all the slaves or a given number of slaves. Every write can specify the number of servers the write has to be propagated to before it returns as successful.</p>
<p class="indent">A command like <code>db.runCommand({ getlasterror : 1 , w : "majority" })</code> tells the database how strong is the consistency you want. For example, if you have one server and specify the <code>w</code> as <code>majority</code>, the write will return immediately since there is only one node. If you have three nodes in the replica set and specify <code>w</code> as <code>majority</code>, the write will have to complete at a minimum of two nodes before it is reported as a success. You can increase the <code>w</code> value for stronger consistency but you will suffer on write performance, since now the writes have to complete at more nodes. Replica sets also allow you to increase the read performance by allowing reading from slaves by setting <code>slaveOk</code>; this parameter can be set on the connection, or database, or collection, or individually for each operation.</p>
<p class="codelink"><a href="images.html#p0111_01" id="p0111_01a">Click here to view code image</a></p>
<p class="programlisting">Mongo mongo = new Mongo("localhost:27017");<br/>mongo.slaveOk();</p>
<p class="indent">Here we are setting <code>slaveOk</code> per operation, so that we can decide which operations can work with data from the slave node.</p>
<p class="codelink"><a href="images.html#p0112_01" id="p0112_01a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_92"/>DBCollection collection = getOrderCollection();<br/>BasicDBObject query = new BasicDBObject();<br/>query.put("name", "Martin");<br/>DBCursor cursor = collection.find(query).slaveOk();</p>
<p class="indent">Similar to various options available for read, you can change the settings to achieve strong write consistency, if desired. By default, a write is reported successful once the database receives it; you can change this so as to wait for the writes to be synced to disk or to propagate to two or more slaves. This is known as <code>WriteConcern</code>: You make sure that certain writes are written to the master and some slaves by setting <code>WriteConcern</code> to <code>REPLICAS_SAFE</code>. Shown below is code where we are setting the <code>WriteConcern</code> for all writes to a collection:</p>
<p class="codelink"><a href="images.html#p0112_02" id="p0112_02a">Click here to view code image</a></p>
<p class="programlisting">DBCollection shopping = database.getCollection("shopping");<br/>shopping.setWriteConcern(REPLICAS_SAFE);</p>
<p class="indent"><code>WriteConcern</code> can also be set per operation by specifying it on the save command:</p>
<p class="codelink"><a href="images.html#p0112_03" id="p0112_03a">Click here to view code image</a></p>
<p class="programlisting">WriteResult result = shopping.insert(order, REPLICAS_SAFE);</p>
<p class="indent">There is a tradeoff that you need to carefully think about, based on your application needs and business requirements, to decide what settings make sense for <code>slaveOk</code> during read or what safety level you desire during write with <code>WriteConcern</code>.</p>
<h4 id="ch09lev2sec2">9.2.2. Transactions</h4>
<p class="noindent">Transactions, in the traditional RDBMS sense, mean that you can start modifying the database with <code>insert</code>, <code>update</code>, or <code>delete</code> commands over different tables and then decide if you want to keep the changes or not by using <code>commit</code> or <code>rollback</code>. These constructs are generally not available in NoSQL solutions—a write either succeeds or fails. Transactions at the single-document level are known as <strong>atomic transactions</strong>. Transactions involving more than one operation are not possible, although there are products such as RavenDB that do support transactions across multiple operations.</p>
<p class="indent">By default, all writes are reported as successful. A finer control over the write can be achieved by using <code>WriteConcern</code> parameter. We ensure that <code>order</code> is written to more than one node before it’s reported successful by using <code>WriteConcern.REPLICAS_SAFE</code>. Different levels of <code>WriteConcern</code> let you choose the safety level during writes; for example, when writing log entries, you can use lowest level of safety, <code>WriteConcern.NONE</code>.</p>
<p class="codelink"><a href="images.html#p0112_04" id="p0112_04a">Click here to view code image</a></p>
<p class="programlisting">final Mongo mongo = new Mongo(mongoURI);<br/>mongo.setWriteConcern(REPLICAS_SAFE);<br/>DBCollection shopping = mongo.getDB(orderDatabase)<br/>                            .getCollection(shoppingCollection);<br/><a id="page_93"/>try {<br/>    WriteResult result = shopping.insert(order, REPLICAS_SAFE);<br/>//Writes made it to primary and at least one secondary<br/>} catch (MongoException writeException) {<br/>//Writes did not make it to minimum of two nodes including primary<br/>    dealWithWriteFailure(order, writeException);<br/>}</p>
<h4 id="ch09lev2sec3">9.2.3. Availability</h4>
<p class="noindent">The CAP theorem (“<a href="ch05.html#ch05lev2sec1">The CAP Theorem</a>,” p. <a href="ch05.html#page_53">53</a>) dictates that we can have only two of Consistency, Availability, and Partition Tolerance. Document databases try to improve on availability by replicating data using the master-slave setup. The same data is available on multiple nodes and the clients can get to the data even when the primary node is down. Usually, the application code does not have to determine if the primary node is available or not. MongoDB implements replication, providing high availability using <strong>replica sets</strong>.</p>
<p class="indent">In a replica set, there are two or more nodes participating in an asynchronous master-slave replication. The replica-set nodes elect the master, or primary, among themselves. Assuming all the nodes have equal voting rights, some nodes can be favored for being closer to the other servers, for having more RAM, and so on; users can affect this by assigning a priority—a number between 0 and 1000—to a node.</p>
<p class="indent">All requests go to the master node, and the data is replicated to the slave nodes. If the master node goes down, the remaining nodes in the replica set vote among themselves to elect a new master; all future requests are routed to the new master, and the slave nodes start getting data from the new master. When the node that failed comes back online, it joins in as a slave and catches up with the rest of the nodes by pulling all the data it needs to get current.</p>
<p class="indent"><a href="#ch09fig01">Figure 9.1</a> is an example configuration of replica sets. We have two nodes, <strong>mongo A</strong> and <strong>mongo B</strong>, running the MongoDB database in the primary data-center, and <strong>mongo C</strong> in the secondary datacenter. If we want nodes in the primary datacenter to be elected as primary nodes, we can assign them a higher priority than the other nodes. More nodes can be added to the replica sets without having to take them offline.</p>
<div class="image"><a id="ch09fig01"/><img alt="Image" src="graphics/09fig01.jpg"/></div>
<p class="fig-caption">Figure 9.1. Replica set configuration with higher priority assigned to nodes in the same datacenter</p>
<p class="indent">The application writes or reads from the primary (master) node. When connection is established, the application only needs to connect to one node (primary or not, does not matter) in the replica set, and the rest of the nodes are discovered automatically. When the primary node goes down, the driver talks to the new primary elected by the replica set. The application does not have to manage any of the communication failures or node selection criteria. Using replica sets gives you the ability to have a highly available document data store.</p>
<p class="indent">Replica sets are generally used for data redundancy, automated failover, read scaling, server maintenance without downtime, and disaster recovery. Similar <a id="page_94"/>availability setups can be achieved with CouchDB, RavenDB, Terrastore, and other products.</p>
<h4 id="ch09lev2sec4">9.2.4. Query Features</h4>
<p class="noindent">Document databases provide different query features. CouchDB allows you to query via views—complex queries on documents which can be either materialized (“<a href="ch03.html#ch03lev1sec4">Materialized Views</a>,” p. <a href="ch03.html#page_30">30</a>) or dynamic (think of them as RDBMS views which are either materialized or not). With CouchDB, if you need to aggregate the number of reviews for a product as well as the average rating, you could add a view implemented via map-reduce (“<a href="ch07.html#ch07lev1sec1">Basic Map-Reduce</a>,” p. <a href="ch07.html#page_68">68</a>) to return the count of reviews and the average of their ratings.</p>
<p class="indent">When there are many requests, you don’t want to compute the count and average for every request; instead you can add a materialized view that precomputes the values and stores the results in the database. These materialized views are updated when queried, if any data was changed since the last update.</p>
<p class="indent">One of the good features of document databases, as compared to key-value stores, is that we can query the data inside the document without having to retrieve the whole document by its key and then introspect the document. This feature brings these databases closer to the RDBMS query model.</p>
<p class="indent">MongoDB has a query language which is expressed via JSON and has constructs such as <code>$query</code> for the <code>where</code> clause, <code>$orderby</code> for sorting the data, or <code>$explain</code> to show the execution plan of the query. There are many more constructs like these that can be combined to create a MongoDB query.</p>
<p class="indent"><a id="page_95"/>Let’s look at certain queries that we can do against MongoDB. Suppose we want to return all the documents in an order collection (all rows in the order table). The SQL for this would be:</p>
<p class="programlisting">SELECT * FROM order</p>
<p class="indent">The equivalent query in Mongo shell would be:</p>
<p class="programlisting">db.order.find()</p>
<p class="indent">Selecting the orders for a single <code>customerId</code> of <code>883c2c5b4e5b</code> would be:</p>
<p class="codelink"><a href="images.html#p0115_01" id="p0115_01a">Click here to view code image</a></p>
<p class="programlisting">SELECT * FROM order WHERE customerId = "883c2c5b4e5b"</p>
<p class="indent">The equivalent query in Mongo to get all orders for a single <code>customerId</code> of <code>883c2c5b4e5b</code>:</p>
<p class="codelink"><a href="images.html#p0115_02" id="p0115_02a">Click here to view code image</a></p>
<p class="programlisting">db.order.find({"customerId":"883c2c5b4e5b"})</p>
<p class="indent">Similarly, selecting <code>orderId</code> and <code>orderDate</code> for one customer in SQL would be:</p>
<p class="codelink"><a href="images.html#p0115_02a" id="p0115_02aa">Click here to view code image</a></p>
<p class="programlisting">SELECT orderId,orderDate FROM order WHERE customerId = "883c2c5b4e5b"</p>
<p class="noindent">and the equivalent in Mongo would be:</p>
<p class="codelink"><a href="images.html#p0115_03" id="p0115_03a">Click here to view code image</a></p>
<p class="programlisting">db.order.find({customerId:"883c2c5b4e5b"},{orderId:1,orderDate:1})</p>
<p class="indent">Similarly, queries to count, sum, and so on are all available. Since the documents are aggregated objects, it is really easy to query for documents that have to be matched using the fields with child objects. Let’s say we want to query for all the orders where one of the items ordered has a name like <code>Refactoring</code>. The SQL for this requirement would be:</p>
<p class="codelink"><a href="images.html#p0115_04" id="p0115_04a">Click here to view code image</a></p>
<p class="programlisting">SELECT * FROM customerOrder, orderItem, product<br/>WHERE<br/>customerOrder.orderId = orderItem.customerOrderId<br/>AND orderItem.productId = product.productId<br/>AND product.name LIKE '%Refactoring%'</p>
<p class="noindent">and the equivalent Mongo query would be:</p>
<p class="codelink"><a href="images.html#p0115_05" id="p0115_05a">Click here to view code image</a></p>
<p class="programlisting">db.orders.find({"items.product.name":/Refactoring/})</p>
<p class="indent">The query for MongoDB is simpler because the objects are embedded inside a single document and you can query based on the embedded child documents.</p>
<h4 id="ch09lev2sec5">9.2.5. Scaling</h4>
<p class="noindent">The idea of scaling is to add nodes or change data storage without simply migrating the database to a bigger box. We are not talking about making application <a id="page_96"/>changes to handle more load; instead, we are interested in what features are in the database so that it can handle more load.</p>
<p class="indent">Scaling for heavy-read loads can be achieved by adding more read slaves, so that all the reads can be directed to the slaves. Given a heavy-read application, with our 3-node replica-set cluster, we can add more read capacity to the cluster as the read load increases just by adding more slave nodes to the replica set to execute reads with the <code>slaveOk</code> flag (<a href="#ch09fig02">Figure 9.2</a>). This is horizontal scaling for reads.</p>
<div class="image"><a id="ch09fig02"/><img alt="Image" src="graphics/09fig02.jpg"/></div>
<p class="fig-caption">Figure 9.2. Adding a new node, mongo D, to an existing replica-set cluster</p>
<p class="indent">Once the new node, mongo D, is started, it needs to be added to the replica set.</p>
<p class="programlisting">rs.add("mongod:27017");</p>
<p class="indent">When a new node is added, it will sync up with the existing nodes, join the replica set as secondary node, and start serving read requests. An advantage of this setup is that we do not have to restart any other nodes, and there is no downtime for the application either.</p>
<p class="indent">When we want to scale for write, we can start sharding (“<a href="ch04.html#ch04lev1sec2">Sharding</a>,” p. <a href="ch04.html#page_38">38</a>) the data. Sharding is similar to partitions in RDBMS where we split data by value in a certain column, such as state or year. With RDBMS, partitions are usually on the same node, so the client application does not have to query a specific partition but can keep querying the base table; the RDBMS takes care of finding the right partition for the query and returns the data.</p>
<p class="indent">In sharding, the data is also split by certain field, but then moved to different Mongo nodes. The data is dynamically moved between nodes to ensure that shards are always balanced. We can add more nodes to the cluster and increase the number of writable nodes, enabling horizontal scaling for writes.</p>
<p class="codelink"><a href="images.html#p0117_01" id="p0117_01a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_97"/>db.runCommand( { shardcollection : "ecommerce.customer",<br/>                 key : {firstname : 1} } )</p>
<p class="indent">Splitting the data on the first name of the customer ensures that the data is balanced across the shards for optimal write performance; furthermore, each shard can be a replica set ensuring better read performance within the shard (<a href="#ch09fig03">Figure 9.3</a>). When we add a new shard to this existing sharded cluster, the data will now be balanced across four shards instead of three. As all this data movement and infrastructure refactoring is happening, the application will not experience any downtime, although the cluster may not perform optimally when large amounts of data are being moved to rebalance the shards.</p>
<div class="image"><a id="ch09fig03"/><img alt="Image" src="graphics/09fig03.jpg"/></div>
<p class="fig-caption">Figure 9.3. MongoDB sharded setup where each shard is a replica set</p>
<p class="indent">The shard key plays an important role. You may want to place your MongoDB database shards closer to their users, so sharding based on user location may be a good idea. When sharding by customer location, all user data for the East Coast of the USA is in the shards that are served from the East Coast, and all user data for the West Coast is in the shards that are on the West Coast.</p>
<h3 id="ch09lev1sec3">9.3. Suitable Use Cases</h3>
<h4 id="ch09lev2sec6">9.3.1. Event Logging</h4>
<p class="noindent">Applications have different event logging needs; within the enterprise, there are many different applications that want to log events. Document databases can store all these different types of events and can act as a central data store for event storage. This is especially true when the type of data being captured by the events keeps changing. Events can be sharded by the name of the application where the event originated or by the type of event such as <code>order_processed</code> or <code>customer_logged</code>.</p>
<h4 id="ch09lev2sec7"><a id="page_98"/>9.3.2. Content Management Systems, Blogging Platforms</h4>
<p class="noindent">Since document databases have no predefined schemas and usually understand JSON documents, they work well in content management systems or applications for publishing websites, managing user comments, user registrations, profiles, web-facing documents.</p>
<h4 id="ch09lev2sec8">9.3.3. Web Analytics or Real-Time Analytics</h4>
<p class="noindent">Document databases can store data for real-time analytics; since parts of the document can be updated, it’s very easy to store page views or unique visitors, and new metrics can be easily added without schema changes.</p>
<h4 id="ch09lev2sec9">9.3.4. E-Commerce Applications</h4>
<p class="noindent">E-commerce applications often need to have flexible schema for products and orders, as well as the ability to evolve their data models without expensive database refactoring or data migration (“<a href="ch12.html#ch12lev1sec3">Schema Changes in a NoSQL Data Store</a>,” p. <a href="ch12.html#page_128">128</a>).</p>
<h3 id="ch09lev1sec4">9.4. When Not to Use</h3>
<p class="noindent">There are problem spaces where document databases are not the best solution.</p>
<h4 id="ch09lev2sec10">9.4.1. Complex Transactions Spanning Different Operations</h4>
<p class="noindent">If you need to have atomic cross-document operations, then document databases may not be for you. However, there are some document databases that do support these kinds of operations, such as RavenDB.</p>
<h4 id="ch09lev2sec11">9.4.2. Queries against Varying Aggregate Structure</h4>
<p class="noindent">Flexible schema means that the database does not enforce any restrictions on the schema. Data is saved in the form of application entities. If you need to query these entities ad hoc, your queries will be changing (in RDBMS terms, this would mean that as you join criteria between tables, the tables to join keep changing). Since the data is saved as an aggregate, if the design of the aggregate is constantly changing, you need to save the aggregates at the lowest level of granularity—basically, you need to normalize the data. In this scenario, document databases may not work.</p>
</body>
</html>