<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 10. Column-Family Stores</title>
<link href="9780133036121.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:612fcd70-0110-46e1-b1de-b4c342e334cd"/>
</head>
<body>
<h2 id="ch10"><a id="page_99"/>Chapter 10. Column-Family Stores</h2>
<p class="noindent">Column-family stores, such as Cassandra <a href="bib01.html#bib_10">[Cassandra]</a>, HBase <a href="bib01.html#bib_31">[Hbase]</a>, Hypertable <a href="bib01.html#bib_36">[Hypertable]</a>, and Amazon SimpleDB <a href="bib01.html#bib_04">[Amazon SimpleDB]</a>, allow you to store data with keys mapped to values and the values grouped into multiple column families, each column family being a map of data.</p>
<div class="image"><img alt="Image" src="graphics/10tab01.jpg"/></div>
<h3 id="ch10lev1sec1">10.1. What Is a Column-Family Data Store?</h3>
<p class="noindent">There are many column-family databases. In this chapter, we will talk about Cassandra but also reference other column-family databases to discuss features that may be of interest in particular scenarios.</p>
<p class="indent">Column-family databases store data in column families as rows that have many columns associated with a row key (<a href="#ch10fig01">Figure 10.1</a>). Column families are groups of related data that is often accessed together. For a <code>Customer</code>, we would often access their <code>Profile</code> information at the same time, but not their <code>Orders</code>.</p>
<div class="image"><a id="ch10fig01"/><img alt="Image" src="graphics/10fig01.jpg"/></div>
<p class="fig-caption">Figure 10.1. Cassandra’s data model with column families</p>
<p class="indent"><a id="page_100"/>Cassandra is one of the popular column-family databases; there are others, such as HBase, Hypertable, and Amazon DynamoDB <a href="bib01.html#bib_03">[Amazon DynamoDB]</a>. Cassandra can be described as fast and easily scalable with write operations spread across the cluster. The cluster does not have a master node, so any read and write can be handled by any node in the cluster.</p>
<h3 id="ch10lev1sec2">10.2. Features</h3>
<p class="noindent">Let’s start by looking at how data is structured in Cassandra. The basic unit of storage in Cassandra is a column. A Cassandra column consists of a name-value pair where the name also behaves as the key. Each of these key-value pairs is a single column and is always stored with a timestamp value. The timestamp is used to expire data, resolve write conflicts, deal with stale data, and do other things. Once the column data is no longer used, the space can be reclaimed later during a compaction phase.</p>
<p class="codelink"><a href="images.html#p0120_01" id="p0120_01a">Click here to view code image</a></p>
<p class="programlisting">{<br/>  name: "fullName",<br/>  value: "Martin Fowler",<br/>  timestamp: 12345667890<br/>}</p>
<p class="indent"><a id="page_101"/>The <code>column</code> has a key of <code>firstName</code> and the value of <code>Martin</code> and has a timestamp attached to it. A row is a collection of columns attached or linked to a key; a collection of similar rows makes a column family. When the columns in a column family are simple columns, the column family is known as <strong>standard column family</strong>.</p>
<p class="codelink"><a href="images.html#p0121_01" id="p0121_01a">Click here to view code image</a></p>
<p class="programlisting">//column family<br/>{<br/>//row<br/>  "pramod-sadalage" : {<br/>     firstName: "Pramod",<br/>     lastName: "Sadalage",<br/>     lastVisit: "2012/12/12"<br/>  }<br/>//row<br/>  "martin-fowler" : {<br/>     firstName: "Martin",<br/>     lastName: "Fowler",<br/>     location: "Boston"<br/>  }<br/>}</p>
<p class="indent">Each column family can be compared to a container of rows in an RDBMS table where the key identifies the row and the row consists on multiple columns. The difference is that various rows do not have to have the same columns, and columns can be added to any row at any time without having to add it to other rows. We have the <code>pramod-sadalage</code> row and the <code>martin-fowler</code> row with different columns; both rows are part of the column family.</p>
<p class="indent">When a column consists of a map of columns, then we have a <strong>super column</strong>. A super column consists of a name and a value which is a map of columns. Think of a super column as a container of columns.</p>
<p class="codelink"><a href="images.html#p0121_02" id="p0121_02a">Click here to view code image</a></p>
<p class="programlisting">{<br/>  name: "book:978-0767905923",<br/>  value: {<br/>    author: "Mitch Albon",<br/>    title: "Tuesdays with Morrie",<br/>    isbn: "978-0767905923"<br/>  }<br/>}</p>
<p class="indent">When we use super columns to create a column family, we get a <strong>super column family</strong>.</p>
<p class="codelink"><a href="images.html#p0122_01a" id="p0122_01aa">Click here to view code image</a></p>
<p class="programlisting"><a id="page_102"/>//super column family<br/>{<br/>//row<br/>name: "billing:martin-fowler",<br/>value: {<br/>  address: {<br/>    name: "address:default",<br/>    value: {<br/>      fullName: "Martin Fowler",<br/>      street:"100 N. Main Street",<br/>      zip: "20145"<br/>    }<br/>  },<br/>  billing: {<br/>    name: "billing:default",<br/>    value: {<br/>      creditcard: "8888-8888-8888-8888",<br/>      expDate: "12/2016"<br/>      }<br/>    }<br/>  }<br/>//row<br/>name: "billing:pramod-sadalage",<br/>value: {<br/>  address: {<br/>    name: "address:default",<br/>    value: {<br/>      fullName: "Pramod Sadalage",<br/>      street:"100 E. State Parkway",<br/>      zip: "54130"<br/>    }<br/>   },<br/>   billing: {<br/>      name: "billing:default",<br/>      value: {<br/>        creditcard: "9999-8888-7777-4444",<br/>        expDate: "01/2016"<br/>        }<br/>      }<br/>   }<br/>}</p>
<p class="indent">Super column families are good to keep related data together, but when some of the columns are not needed most of the time, the columns are still fetched and deserialized by Cassandra, which may not be optimal.</p>
<p class="indent">Cassandra puts the standard and super column families into <strong>keyspaces</strong>. A keyspace is similar to a database in RDBMS where all column families related to the application are stored. Keyspaces have to be created so that column families can be assigned to them:</p>
<p class="programlisting">create keyspace ecommerce</p>
<h4 id="ch10lev2sec1"><a id="page_103"/>10.2.1. Consistency</h4>
<p class="noindent">When a write is received by Cassandra, the data is first recorded in a commit log, then written to an in-memory structure known as <strong>memtable</strong>. A write operation is considered successful once it’s written to the commit log and the memtable. Writes are batched in memory and periodically written out to structures known as <strong>SSTable</strong>. SSTables are not written to again after they are flushed; if there are changes to the data, a new SSTable is written. Unused SSTables are reclaimed by <strong>compactation</strong>.</p>
<p class="indent">Let’s look at the read operation to see how consistency settings affect it. If we have a consistency setting of <code>ONE</code> as the default for all read operations, then when a read request is made, Cassandra returns the data from the first replica, even if the data is stale. If the data is stale, subsequent reads will get the latest (newest) data; this process is known as <strong>read repair</strong>. The low consistency level is good to use when you do not care if you get stale data and/or if you have high read performance requirements.</p>
<p class="indent">Similarly, if you are doing writes, Cassandra would write to one node’s commit log and return a response to the client. The consistency of <code>ONE</code> is good if you have very high write performance requirements and also do not mind if some writes are lost, which may happen if the node goes down before the write is replicated to other nodes.</p>
<p class="codelink"><a href="images.html#p0123_01" id="p0123_01a">Click here to view code image</a></p>
<p class="programlisting">quorum = new ConfigurableConsistencyLevel();<br/>quorum.setDefaultReadConsistencyLevel(HConsistencyLevel.QUORUM);<br/>quorum.setDefaultWriteConsistencyLevel(HConsistencyLevel.QUORUM);</p>
<p class="indent">Using the <code>QUORUM</code> consistency setting for both read and write operations ensures that majority of the nodes respond to the read and the column with the newest timestamp is returned back to the client, while the replicas that do not have the newest data are repaired via the read repair operations. During write operations, the <code>QUORUM</code> consistency setting means that the write has to propagate to the majority of the nodes before it is considered successful and the client is notified.</p>
<p class="indent">Using <code>ALL</code> as consistency level means that all nodes will have to respond to reads or writes, which will make the cluster not tolerant to faults—even when one node is down, the write or read is blocked and reported as a failure. It’s therefore upon the system designers to tune the consistency levels as the application requirements change. Within the same application, there may be different requirements of consistency; they can also change based on each operation, for example showing review comments for a product has different consistency requirements compared to reading the status of the last order placed by the customer.</p>
<p class="indent">During <strong>keyspace</strong> creation, we can configure how many replicas of the data we need to store. This number determines the replication factor of the data. If you have a replication factor of 3, the data copied on to three nodes. When writing and reading data with Cassandra, if you specify the consistency values of 2, you <a id="page_104"/>get that <code>R + W</code> is greater than the replication factor <code>(2 + 2 &gt; 3)</code> which gives you better consistency during writes and reads.</p>
<p class="indent">We can run the node repair command for the keyspace and force Cassandra to compare every key it’s responsible for with the rest of the replicas. As this operation is expensive, we can also just repair a specific column family or a list of column families:</p>
<p class="programlisting">repair ecommerce<br/><br/>repair ecommerce customerInfo</p>
<p class="indent">While a node is down, the data that was supposed to be stored by that node is handed off to other nodes. As the node comes back online, the changes made to the data are handed back to the node. This technique is known as <strong>hinted handoff</strong>. Hinted handoff allows for faster restore of failed nodes.</p>
<h4 id="ch10lev2sec2">10.2.2. Transactions</h4>
<p class="noindent">Cassandra does not have transactions in the traditional sense—where we could start multiple writes and then decide if we want to commit the changes or not. In Cassandra, a write is atomic at the row level, which means inserting or updating columns for a given row key will be treated as a single write and will either succeed or fail. Writes are first written to commit logs and memtables, and are only considered good when the write to commit log and memtable was successful. If a node goes down, the commit log is used to apply changes to the node, just like the <strong>redo log</strong> in Oracle.</p>
<p class="indent">You can use external transaction libraries, such as ZooKeeper <a href="bib01.html#bib_68">[ZooKeeper]</a>, to synchronize your writes and reads. There are also libraries such as Cages <a href="bib01.html#bib_09">[Cages]</a> that allow you to wrap your transactions over ZooKeeper.</p>
<h4 id="ch10lev2sec3">10.2.3. Availability</h4>
<p class="noindent">Cassandra is by design highly available, since there is no master in the cluster and every node is a peer in the cluster. The availability of a cluster can be increased by reducing the consistency level of the requests. Availability is governed by the <code>(R + W) &gt; N</code> formula (“<a href="ch05.html#ch05lev1sec5">Quorums</a>,” p. <a href="ch05.html#page_57">57</a>) where <code>W</code> is the minimum number of nodes where the write must be successfully written, <code>R</code> is the minimum number of nodes that must respond successfully to a read, and <code>N</code> is the number of nodes participating in the replication of data. You can tune the availability by changing the <code>R</code> and <code>W</code> values for a fixed value of <code>N</code>.</p>
<p class="indent">In a 10-node Cassandra cluster with a replication factor for the keyspace set to 3 (<code>N = 3</code>), if we set <code>R = 2</code> and <code>W = 2</code>, then we have <code>(2 + 2) &gt; 3</code>. In this scenario, when one node goes down, availability is not affected much, as the data can be retrieved from the other two nodes. If <code>W = 2</code> and <code>R = 1</code>, when two nodes are down the cluster is not available for write but we can still read. Similarly, if <a id="page_105"/><code>R = 2</code> and <code>W = 1</code>, we can write but the cluster is not available for read. With the <code>R + W &gt; N</code> equation, you are making conscious decisions about consistency tradeoffs.</p>
<p class="indent">You should set up your keyspaces and read/write operations based on your needs—higher availability for write or higher availability for read.</p>
<h4 id="ch10lev2sec4">10.2.4. Query Features</h4>
<p class="noindent">When designing the data model in Cassandra, it is advised to make the columns and column families optimized for reading the data, as it does not have a rich query language; as data is inserted in the column families, data in each row is sorted by column names. If we have a column that is retrieved much more often than other columns, it’s better performance-wise to use that value for the row key instead.</p>
<h5 id="ch10lev3sec1">10.2.4.1. Basic Queries</h5>
<p class="noindent">Basic queries that can be run using a Cassandra client include the <code>GET</code>, <code>SET</code>, and <code>DEL</code>. Before starting to query for data, we have to issue the keyspace command <code>use ecommerce;</code>. This ensures that all of our queries are run against the keyspace that we put our data into. Before starting to use the column family in the keyspace, we have to define the column family.</p>
<p class="codelink"><a href="images.html#p0125_01" id="p0125_01a">Click here to view code image</a></p>
<p class="programlisting">CREATE COLUMN FAMILY Customer<br/>WITH comparator = UTF8Type<br/>AND key_validation_class=UTF8Type<br/>AND column_metadata = [<br/>{column_name: city, validation_class: UTF8Type}<br/>{column_name: name, validation_class: UTF8Type}<br/>{column_name: web, validation_class: UTF8Type}<br/>];</p>
<p class="indent">We have a column family named <code>Customer</code> with <code>name</code>, <code>city</code>, and <code>web</code> columns, and we are inserting data in the column family with a Cassandra client.</p>
<p class="codelink"><a href="images.html#p0125_02" id="p0125_02a">Click here to view code image</a></p>
<p class="programlisting">SET Customer['mfowler']['city']='Boston';<br/>SET Customer['mfowler']['name']='Martin Fowler';<br/>SET Customer['mfowler']['web']='www.martinfowler.com';</p>
<p class="indent">Using the Hector <a href="bib01.html#bib_32">[Hector]</a> Java client, we can insert the same data in the column family.</p>
<p class="codelink"><a href="images.html#p0125_03" id="p0125_03a">Click here to view code image</a></p>
<p class="programlisting">ColumnFamilyTemplate&lt;String, String&gt; template =<br/>        cassandra.getColumnFamilyTemplate();<br/>ColumnFamilyUpdater&lt;String, String&gt; updater =<br/>        template.createUpdater(key);<br/>for (String name : values.keySet()) {<br/>    updater.setString(name, values.get(name));<br/>}<br/><a id="page_106"/>try {<br/>    template.update(updater);<br/>} catch (HectorException e) {<br/>    handleException(e);<br/>}</p>
<p class="indent">We can read the data back using the <code>GET</code> command. There are multiple ways to get the data; we can get the whole column family.</p>
<p class="programlisting">GET Customer['mfowler'];</p>
<p class="indent">We can even get just the column we are interested in from the column family.</p>
<p class="programlisting">GET Customer['mfowler']['web'];</p>
<p class="indent">Getting the specific column we need is more efficient, as only the data we care about is returned—which saves lots of data movement, especially when the column family has a large number of columns. Updating the data is the same as using the <code>SET</code> command for the column that needs to be set to the new value. Using <code>DEL</code> command, we can delete either a column or the entire column family.</p>
<p class="codelink"><a href="images.html#p0126_01" id="p0126_01a">Click here to view code image</a></p>
<p class="programlisting">DEL Customer['mfowler']['city'];<br/><br/>DEL Customer['mfowler'];</p>
<h5 id="ch10lev3sec2">10.2.4.2. Advanced Queries and Indexing</h5>
<p class="noindent">Cassandra allows you to index columns other than the keys for the column family. We can define an index on the <code>city</code> column.</p>
<p class="codelink"><a href="images.html#p0126_02" id="p0126_02a">Click here to view code image</a></p>
<p class="programlisting">UPDATE COLUMN FAMILY Customer<br/>WITH comparator = UTF8Type<br/>AND column_metadata = [{column_name: city,<br/>                        validation_class: UTF8Type,<br/>                        index_type: KEYS}];</p>
<p class="indent">We can now query directly against the indexed column.</p>
<p class="programlisting">GET Customer WHERE city = 'Boston';</p>
<p class="indent">These indexes are implemented as <em>bit-mapped</em> indexes and perform well for low-cardinality column values.</p>
<h5 id="ch10lev3sec3">10.2.4.3. Cassandra Query Language (CQL)</h5>
<p class="noindent">Cassandra has a query language that supports SQL-like commands, known as Cassandra Query Language (CQL). We can use the CQL commands to create a column family.</p>
<p class="codelink"><a href="images.html#p0127_01" id="p0127_01a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_107"/>CREATE COLUMNFAMILY Customer (<br/>  KEY varchar PRIMARY KEY,<br/>  name varchar,<br/>  city varchar,<br/>  web  varchar);</p>
<p class="indent">We insert the same data using CQL.</p>
<p class="codelink"><a href="images.html#p0127_02" id="p0127_02a">Click here to view code image</a></p>
<p class="programlisting">INSERT INTO Customer (KEY,name,city,web)<br/>  VALUES ('mfowler',<br/>            'Martin Fowler',<br/>            'Boston',<br/>            'www.martinfowler.com');</p>
<p class="indent">We can read data using the <code>SELECT</code> command. Here we read all the columns:</p>
<p class="programlisting">SELECT * FROM Customer</p>
<p class="indent">Or, we could just <code>SELECT</code> the columns we need.</p>
<p class="programlisting">SELECT name,web FROM Customer</p>
<p class="indent">Indexing columns are created using the <code>CREATE INDEX</code> command, and then can be used to query the data.</p>
<p class="codelink"><a href="images.html#p0127_03" id="p0127_03a">Click here to view code image</a></p>
<p class="programlisting">SELECT name,web FROM Customer WHERE city='Boston'</p>
<p class="indent">CQL has many more features for querying data, but it does not have all the features that SQL has. CQL does not allow joins or subqueries, and its <code>where</code> clauses are typically simple.</p>
<h4 id="ch10lev2sec5">10.2.5. Scaling</h4>
<p class="noindent">Scaling an existing Cassandra cluster is a matter of adding more nodes. As no single node is a master, when we add nodes to the cluster we are improving the capacity of the cluster to support more writes and reads. This type of horizontal scaling allows you to have maximum uptime, as the cluster keeps serving requests from the clients while new nodes are being added to the cluster.</p>
<h3 id="ch10lev1sec3">10.3. Suitable Use Cases</h3>
<p class="noindent">Let’s discuss some of the problems where column-family databases are a good fit.</p>
<h4 id="ch10lev2sec6">10.3.1. Event Logging</h4>
<p class="noindent">Column-family databases with their ability to store any data structures are a great choice to store event information, such as application state or errors <a id="page_108"/>encountered by the application. Within the enterprise, all applications can write their events to Cassandra with their own columns and the rowkey of the form <code>appname:timestamp</code>. Since we can scale writes, Cassandra would work ideally for an event logging system (<a href="#ch10fig02">Figure 10.2</a>).</p>
<div class="image"><a id="ch10fig02"/><img alt="Image" src="graphics/10fig02.jpg"/></div>
<p class="fig-caption">Figure 10.2. Event logging with Cassandra</p>
<h4 id="ch10lev2sec7">10.3.2. Content Management Systems, Blogging Platforms</h4>
<p class="noindent">Using column families, you can store blog entries with tags, categories, links, and trackbacks in different columns. Comments can be either stored in the same row or moved to a different keyspace; similarly, blog users and the actual blogs can be put into different column families.</p>
<h4 id="ch10lev2sec8">10.3.3. Counters</h4>
<p class="noindent">Often, in web applications you need to count and categorize visitors of a page to calculate analytics. You can use the <code>CounterColumnType</code> during creation of a column family.</p>
<p class="codelink"><a href="images.html#p0128_01" id="p0128_01a">Click here to view code image</a></p>
<p class="programlisting">CREATE COLUMN FAMILY visit_counter<br/>WITH default_validation_class=CounterColumnType<br/>AND key_validation_class=UTF8Type AND comparator=UTF8Type;</p>
<p class="indent">Once a column family is created, you can have arbitrary columns for each page visited within the web application for every user.</p>
<p class="codelink"><a href="images.html#p0128_02" id="p0128_02a">Click here to view code image</a></p>
<p class="programlisting">INCR visit_counter['mfowler'][home] BY 1;<br/>INCR visit_counter['mfowler'][products] BY 1;<br/>INCR visit_counter['mfowler'][contactus] BY 1;</p>
<p class="indent">Incrementing counters using CQL:</p>
<p class="codelink"><a href="images.html#p0128_03" id="p0128_03a">Click here to view code image</a></p>
<p class="programlisting">UPDATE visit_counter SET home = home + 1 WHERE KEY='mfowler'</p>
<h4 id="ch10lev2sec9">10.3.4. Expiring Usage</h4>
<p class="noindent">You may provide demo access to users, or may want to show ad banners on a website for a specific time. You can do this by using <strong>expiring columns</strong>: Cassandra allows you to have columns which, after a given time, are deleted automatically. This time is known as TTL (Time To Live) and is defined in seconds. The column <a id="page_109"/>is deleted after the TTL has elapsed; when the column does not exist, the access can be revoked or the banner can be removed.</p>
<p class="codelink"><a href="images.html#p0129_01" id="p0129_01a">Click here to view code image</a></p>
<p class="programlisting">SET Customer['mfowler']['demo_access'] = 'allowed' WITH ttl=2592000;</p>
<h3 id="ch10lev1sec4">10.4. When Not to Use</h3>
<p class="noindent">There are problems for which column-family databases are not the best solutions, such as systems that require ACID transactions for writes and reads. If you need the database to aggregate the data using queries (such as <code>SUM</code> or <code>AVG</code>), you have to do this on the client side using data retrieved by the client from all the rows.</p>
<p class="indent">Cassandra is not great for early prototypes or initial tech spikes: During the early stages, we are not sure how the query patterns may change, and as the query patterns change, we have to change the column family design. This causes friction for the product innovation team and slows down developer productivity. RDBMS impose high cost on schema change, which is traded off for a low cost of query change; in Cassandra, the cost may be higher for query change as compared to schema change.</p>
</body>
</html>