<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 12. Schema Migrations</title>
<link href="9780133036121.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:612fcd70-0110-46e1-b1de-b4c342e334cd"/>
</head>
<body>
<h2 id="ch12"><a id="page_123"/>Chapter 12. Schema Migrations</h2>
<h3 id="ch12lev1sec1">12.1. Schema Changes</h3>
<p class="noindent">The recent trend in discussing NoSQL databases is to highlight their <em>schemaless</em> nature—it is a popular feature that allows developers to concentrate on the domain design without worrying about schema changes. It’s especially true with the rise of agile methods <a href="bib01.html#bib_01">[Agile Methods]</a> where responding to changing requirements is important.</p>
<p class="indent">Discussions, iterations, and feedback loops involving domain experts and product owners are important to derive the right understanding of the data; these discussions must not be hampered by a database’s schema complexity. With NoSQL data stores, changes to the schema can be made with the least amount of friction, improving developer productivity (“<a href="ch01.html#ch01lev1sec5">The Emergence of NoSQL</a>,” p. <a href="ch01.html#page_9">9</a>). We have seen that developing and maintaining an application in the brave new world of schemaless databases requires careful attention to be given to schema migration.</p>
<h3 id="ch12lev1sec2">12.2. Schema Changes in RDBMS</h3>
<p class="noindent">While developing with standard RDBMS technologies, we develop objects, their corresponding tables, and their relationships. Consider a simple object model and data model that has <code>Customer</code>, <code>Order</code>, and <code>OrderItems</code>. The ER model would look like <a href="#ch12fig01">Figure 12.1</a>.</p>
<div class="image"><a id="ch12fig01"/><img alt="Image" src="graphics/12fig01.jpg"/></div>
<p class="fig-caption">Figure 12.1. Data model of an e-commerce system</p>
<p class="indent">While this data model supports the current object model, life is good. The first time there is a change in the object model, such as introducing <code>preferredShippingType</code> on the <code>Customer</code> object, we have to change the object and change the database table, because without changing the table the application will be out of sync with the database. When we get errors like <code>ORA-00942: table or view does not exist</code> <a id="page_124"/>or <code>ORA-00904: "PREFERRED_SHIPPING_TYPE": invalid identifier</code>, we know we have this problem.</p>
<p class="indent">Typically, a database schema migration has been a project in itself. For deployment of the schema changes, database change scripts are developed, using diff techniques, for all the changes in the development database. This approach of creating migration scripts during the deployment/release time is error-prone and does not support agile development methods.</p>
<h4 id="ch12lev2sec1">12.2.1. Migrations for Green Field Projects</h4>
<p class="noindent">Scripting the database schema changes during development is better, since we can store these schema changes along with the data migration scripts in the same script file. These script files should be named with incrementing sequential numbers which reflect the database versions; for example, the first change to the database could have script file named as <code>001_Description_Of_Change.sql</code>. Scripting changes this way allows for the database migrations to be run preserving the order of changes. Shown in <a href="#ch12fig02">Figure 12.2</a> is a folder of all the changes done to a database so far.</p>
<div class="image"><a id="ch12fig02"/><img alt="Image" src="graphics/12fig02.jpg"/></div>
<p class="fig-caption">Figure 12.2. Sequence of migrations applied to a database</p>
<p class="indent"><a id="page_125"/>Now, suppose we need to change the <code>OrderItem</code> table to store the <code>DiscountedPrice</code> and the <code>FullPrice</code> of the item. This will need a change to the <code>OrderItem</code> table and will be change number <code>007</code> in our sequence of changes, as shown in <a href="#ch12fig03">Figure 12.3</a>.</p>
<div class="image"><a id="ch12fig03"/><img alt="Image" src="graphics/12fig03.jpg"/></div>
<p class="fig-caption">Figure 12.3. New change <span class="EmpStrong">007_DiscountedPrice.sql</span> applied to the database</p>
<p class="indent">We applied a new change to the database. This change’s script has the code for adding a new column, renaming the existing column, and migrating the data needed to make the new feature work. Shown below is the script contained in the change <code>007_DiscountedPrice.sql</code>:</p>
<p class="codelink"><a href="images.html#p0145_01" id="p0145_01a">Click here to view code image</a></p>
<p class="programlisting">ALTER TABLE orderitem ADD discountedprice NUMBER(18,2) NULL;<br/>UPDATE orderitem SET discountedprice = price;<br/>ALTER TABLE orderitem MODIFY discountedprice NOT NULL;<br/>ALTER TABLE orderitem RENAME COLUMN price TO fullprice;<br/>--//@UNDO<br/>ALTER TABLE orderitem RENAME fullprice TO price;<br/>ALTER TABLE orderitem DROP COLUMN discountedprice;</p>
<p class="indent">The change script shows the schema changes to the database as well as the data migrations needed to be done. In the example shown, we are using DBDeploy <a href="bib01.html#bib_18">[DBDeploy]</a> as the framework to manage the changes to the database. DBDeploy maintains a table in the database, named <code>ChangeLog</code>, where all the changes made to the database are stored. In this table, <code>Change_Number</code> is what tells everyone which changes have been applied to the database. This <code>Change_Number</code>, which is the database version, is then used to find the corresponding numbered script in the folder and apply the changes which have not been applied yet. When we write a script with the change number <code>007</code> and apply it to the database using DBDeploy, DBDeploy will check the <code>ChangeLog</code> and pick up all the scripts from the folder that have not yet been applied. <a href="#ch12fig04">Figure 12.4</a> is the screenshot of DBDeploy applying the change to the database.</p>
<div class="image"><a id="ch12fig04"/><img alt="Image" src="graphics/12fig04.jpg"/></div>
<p class="fig-caption">Figure 12.4. DBDeploy upgrading the database with change number 007</p>
<p class="indent">The best way to integrate with the rest of the developers is to use your project’s version control repository to store all these change scripts, so that you can keep track of the version of the software and the database in the same place, eliminating <a id="page_126"/>possible mismatches between the database and the application. There are many other tools for such upgrades, including Liquibase <a href="bib01.html#bib_40">[Liquibase]</a>, MyBatis Migrator <a href="bib01.html#bib_46">[MyBatis Migrator]</a>, DBMaintain <a href="bib01.html#bib_19">[DBMaintain]</a>.</p>
<h4 id="ch12lev2sec2">12.2.2. Migrations in Legacy Projects</h4>
<p class="noindent">Not every project is a green field. How to implement migrations when an existing application is in production? We found that taking an existing database and extracting its structure into scripts, along with all the database code and any reference data, works as a baseline for the project. This baseline should not contain transactional data. Once the baseline is ready, further changes can be done using the migrations technique described above (<a href="#ch12fig05">Figure 12.5</a>).</p>
<div class="image"><a id="ch12fig05"/><img alt="Image" src="graphics/12fig05.jpg"/></div>
<p class="fig-caption">Figure 12.5. Use of baseline scripts with a legacy database</p>
<p class="indent">One of the main aspects of migrations should be maintaining backward compatibility of the database schema. In many enterprises there are multiple applications using the database; when we change the database for one application, this change should not break other applications. We can achieve backward compatibility by maintaining a transition phase for the change, as described in detail in <em>Refactoring Databases</em> <a href="bib01.html#bib_05">[Ambler and Sadalage]</a>.</p>
<p class="indent">During a <strong>transition phase</strong>, the old schema and the new schema are maintained in parallel and are available for all the applications using the database. For this, we have to introduce scaffolding code, such as triggers, views, and virtual columns <a id="page_127"/>ensuring other applications can access the database schema and the data they require without any code changes.</p>
<p class="codelink"><a href="images.html#p0147_01" id="p0147_01a">Click here to view code image</a></p>
<p class="programlisting">ALTER TABLE customer ADD fullname VARCHAR2(60);<br/>UPDATE customer SET fullname = fname;<br/><br/>CREATE OR REPLACE TRIGGER SyncCustomerFullName<br/>BEFORE INSERT OR UPDATE<br/>ON customer<br/>REFERENCING OLD AS OLD NEW AS NEW<br/>FOR EACH ROW<br/>BEGIN<br/>  IF :NEW.fname IS NULL THEN<br/>    :NEW.fname := :NEW.fullname;<br/>  END IF;<br/>  IF :NEW.fullname IS NULL THEN<br/>    :NEW.fullname := :NEW.fname<br/>  END IF;<br/>END;<br/>/<br/><br/>--Drop Trigger and fname<br/>--when all applications start using customer.fullname</p>
<p class="indent">In the example, we are trying to rename the <code>customer.fname</code> column to <code>customer.fullname</code> as we want to avoid any ambiguity of <code>fname</code> meaning either <code>fullname</code> or <code>firstname</code>. A direct rename of the <code>fname</code> column and changing the application code we are responsible for may just work, for our application—but will not for the other applications in the enterprise that are accessing the same database.</p>
<p class="indent"><a id="page_128"/>Using the transition phase technique, we introduce the new column <code>fullname</code>, copy the data over to <code>fullname</code>, but leave the old column <code>fname</code> around. We also introduce a <code>BEFORE UPDATE</code> trigger to synchronize data between the columns before they are committed to the database.</p>
<p class="indent">Now, when applications read data from the table, they will read either from <code>fname</code> or from <code>fullname</code> but will always get the right data. We can drop the trigger and the <code>fname</code> column once all the applications have moved on to using the new <code>fullname</code> column.</p>
<p class="indent">It’s very hard to do schema migrations on large datasets in RDBMS, especially if we have to keep the database available to the applications, as large data movements and structural changes usually create locks on the database tables.</p>
<h3 id="ch12lev1sec3">12.3. Schema Changes in a NoSQL Data Store</h3>
<p class="noindent">An RDBMS database has to be changed before the application is changed. This is what the <em>schema-free</em>, or <em>schemaless</em>, approach tries to avoid, aiming at flexibility of schema changes per entity. Frequent changes to the schema are needed to react to frequent market changes and product innovations.</p>
<p class="indent">When developing with NoSQL databases, in some cases the schema does not have to be thought about beforehand. We still have to design and think about other aspects, such as the types of relationships (with graph databases), or the names of the column families, rows, columns, order of columns (with column databases), or how are the keys assigned and what is the structure of the data inside the value object (with key-value stores). Even if we didn’t think about these up front, or if we want to change our decisions, it is easy to do so.</p>
<p class="indent">The claim that NoSQL databases are entirely schemaless is misleading; while they store the data without regard to the schema the data adheres to, that schema has to be defined by the application, because the data stream has to be parsed by the application when reading the data from the database. Also, the application has to create the data that would be saved in the database. If the application cannot parse the data from the database, we have a schema mismatch even if, instead of the RDBMS database throwing a error, this error is now encountered by the application. Thus, even in schemaless databases, the schema of the data has to be taken into consideration when refactoring the application.</p>
<p class="indent">Schema changes especially matter when there is a deployed application and existing production data. For the sake of simplicity, assume we are using a document data store like MongoDB <a href="bib01.html#bib_44">[MongoDB]</a> and we have the same data model as before: <code>customer</code>, <code>order</code>, and <code>orderItems</code>.</p>
<p class="codelink"><a href="images.html#p0149_01" id="p0149_01a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_129"/>{<br/>"_id": "4BD8AE97C47016442AF4A580",<br/>"customerid": 99999,<br/>"name": "Foo Sushi Inc",<br/>"since": "12/12/2012",<br/>"order": {<br/>    "orderid": "4821-UXWE-122012","orderdate": "12/12/2001",<br/>    "orderItems": [{"product": "Fortune Cookies",<br/>                    "price": 19.99}]<br/>    }<br/>}</p>
<p class="indent">Application code to write this document structure to MongoDB:</p>
<p class="codelink"><a href="images.html#p0149_02" id="p0149_02a">Click here to view code image</a></p>
<p class="programlisting">BasicDBObject orderItem = new BasicDBObject();<br/>orderItem.put("product", productName);<br/>orderItem.put("price", price);<br/>orderItems.add(orderItem);</p>
<p class="indent">Code to read the document back from the database:</p>
<p class="codelink"><a href="images.html#p0149_03a" id="p0149_03aa">Click here to view code image</a></p>
<p class="programlisting">BasicDBObject item = (BasicDBObject) orderItem;<br/>String productName = item.getString("product");<br/>Double price = item.getDouble("price");</p>
<p class="indent">Changing the objects to add <code>preferredShippingType</code> does not require any change in the database, as the database does not care that different documents do not follow the same schema. This allows for faster development and easy deployments. All that needs to be deployed is the application—no changes on the database side are needed. The code has to make sure that documents that do not have the <code>preferredShippingType</code> attribute can still be parsed—and that’s all.</p>
<p class="indent">Of course we are simplifying the schema change situation here. Let’s look at the schema change we made before: introducing <code>discountedPrice</code> and renaming price to <code>fullPrice</code>. To make this change, we rename the <code>price</code> attribute to <code>fullPrice</code> and add <code>discountedPrice</code> attribute. The changed document is</p>
<p class="codelink"><a href="images.html#p0149_03" id="p0149_03a">Click here to view code image</a></p>
<p class="programlisting">{<br/>"_id": "5BD8AE97C47016442AF4A580",<br/>"customerid": 66778,<br/>"name": "India House",<br/>"since": "12/12/2012",<br/>"order": {<br/>  "orderid": "4821-UXWE-222012",<br/>    "orderdate": "12/12/2001",<br/>    "orderItems": [{"product": "Chair Covers",<br/>                    "fullPrice": 29.99,<br/>                    "discountedPrice":26.99}]<br/>    }<br/>}</p>
<p class="indent">Once we deploy this change, new customers and their orders can be saved and read back without problems, but for existing orders the price of their product <a id="page_130"/>cannot be read, because now the code is looking for <code>fullPrice</code> but the document has only <code>price</code>.</p>
<h4 id="ch12lev2sec3">12.3.1. Incremental Migration</h4>
<p class="noindent">Schema mismatch trips many new converts to the NoSQL world. When schema is changed on the application, we have to make sure to convert all the existing data to the new schema (depending on data size, this might be an expensive operation). Another option would be to make sure that data, before the schema changed, can still be parsed by the new code, and when it’s saved, it is saved back in the new schema. This technique, known as <strong>incremental migration</strong>, will migrate data over time; some data may never get migrated, because it was never accessed. We are reading both <code>price</code> and <code>fullPrice</code> from the document:</p>
<p class="codelink"><a href="images.html#p0150_01" id="p0150_01a">Click here to view code image</a></p>
<p class="programlisting">BasicDBObject item = (BasicDBObject) orderItem;<br/>String productName = item.getString("product");<br/>Double fullPrice = item.getDouble("price");<br/>if (fullPrice == null) {<br/>    fullPrice = item.getDouble("fullPrice");<br/>}<br/>Double discountedPrice = item.getDouble("discountedPrice");</p>
<p class="indent">When writing the document back, the old attribute <code>price</code> is not saved:</p>
<p class="codelink"><a href="images.html#p0150_02" id="p0150_02a">Click here to view code image</a></p>
<p class="programlisting">BasicDBObject orderItem = new BasicDBObject();<br/>orderItem.put("product", productName);<br/>orderItem.put("fullPrice", price);<br/>orderItem.put("discountedPrice", discountedPrice);<br/>orderItems.add(orderItem);</p>
<p class="indent">When using incremental migration, there could be many versions of the object on the application side that can translate the old schema to the new schema; while saving the object back, it is saved using the new object. This gradual migration of the data helps the application evolve faster.</p>
<p class="indent">The incremental migration technique will complicate the object design, especially as new changes are being introduced yet old changes are not being taken out. This period between the change deployment and the last object in the database migrating to the new schema is known as the transition period (<a href="#ch12fig06">Figure 12.6</a>). Keep it as short as possible and focus it to the minimum possible scope—this will help you keep your objects clean.</p>
<div class="image"><a id="ch12fig06"/><img alt="Image" src="graphics/12fig06.jpg"/></div>
<p class="fig-caption">Figure 12.6. Transition period of schema changes</p>
<p class="indent">The incremental migration technique can also be implemented with a <code>schema_version</code> field on the data, used by the application to choose the correct code to parse the data into the objects. When saving, the data is migrated to the latest version and the <code>schema_version</code> is updated to reflect that.</p>
<p class="indent">Having a proper translation layer between your domain and the database is important so that, as the schema changes, managing multiple versions of the <a id="page_131"/>schema is restricted to the translation layer and does not leak into the whole application.</p>
<p class="indent">Mobile apps create special requirements. Since we cannot enforce the latest upgrades of the application, the application should be able to handle almost all versions of the schema.</p>
<h4 id="ch12lev2sec4">12.3.2. Migrations in Graph Databases</h4>
<p class="noindent">Graph databases have edges that have types and properties. If you change the type of these edges in the codebase, you no longer can traverse the database, rendering it unusable. To get around this, you can traverse all the edges and change the type of each edge. This operation can be expensive and requires you to write code to migrate all the edges in the database.</p>
<p class="indent">If we need to maintain backward compatibility or do not want to change the whole graph in one go, we can just create new edges between the nodes; later when we are comfortable about the change, the old edges can be dropped. We can use traversals with multiple edge types to traverse the graph using the new and old edge types. This technique may help a great deal with large databases, especially if we want to maintain high availability.</p>
<p class="indent">If we have to change properties on all the nodes or edges, we have to fetch all the nodes and change all the properties that need to be changed. An example would be adding <code>NodeCreatedBy</code> and <code>NodeCreatedOn</code> to all existing nodes to track the changes being made to each node.</p>
<p class="codelink"><a href="images.html#p0152_01" id="p0152_01a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_132"/>for (Node node : database.getAllNodes()) {<br/>    node.setProperty("NodeCreatedBy", getSystemUser());<br/>    node.setProperty("NodeCreatedOn", getSystemTimeStamp());<br/>}</p>
<p class="indent">We may have to change the data in the nodes. New data may be derived from the existing node data, or it could be imported from some other source. The migration can be done by fetching all nodes using an index provided by the source of data and writing relevant data to each node.</p>
<h4 id="ch12lev2sec5">12.3.3. Changing Aggregate Structure</h4>
<p class="noindent">Sometimes you need to change the schema design, for example by splitting large objects into smaller ones that are stored independently. Suppose you have a customer aggregate that contains all the customers orders, and you want to separate the customer and each of their orders into different aggregate units.</p>
<p class="indent">You then have to ensure that the code can work with both versions of the aggregates. If it does not find the old objects, it will look for the new aggregates.</p>
<p class="indent">Code that runs in the background can read one aggregate at a time, make the necessary change, and save the data back into different aggregates. The advantage of operating on one aggregate at a time is that this way, you’re not affecting data availability for the application.</p>
<h3 id="ch12lev1sec4">12.4. Further Reading</h3>
<p class="noindent">For more on migrations with relational databases, see <a href="bib01.html#bib_05">[Ambler and Sadalage]</a>. Although much of this content is specific to relational work, the general principles in migration will also apply to other databases.</p>
<h3 id="ch12lev1sec5">12.5. Key Points</h3>
<p class="indenthangingB">• Databases with strong schemas, such as relational databases, can be migrated by saving each schema change, plus its data migration, in a version-controlled sequence.</p>
<p class="indenthangingB">• Schemaless databases still need careful migration due to the implicit schema in any code that accesses the data.</p>
<p class="indenthangingB">• Schemaless databases can use the same migration techniques as databases with strong schemas.</p>
<p class="indenthangingB">• Schemaless databases can also read data in a way that’s tolerant to changes in the data’s implicit schema and use incremental migration to update data.</p>
</body>
</html>