<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 11. Graph Databases</title>
<link href="9780133036121.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:612fcd70-0110-46e1-b1de-b4c342e334cd"/>
</head>
<body>
<h2 id="ch11"><a id="page_111"/>Chapter 11. Graph Databases</h2>
<p class="noindent">Graph databases allow you to store entities and relationships between these entities. Entities are also known as nodes, which have properties. Think of a node as an instance of an object in the application. Relations are known as edges that can have properties. Edges have directional significance; nodes are organized by relationships which allow you to find interesting patterns between the nodes. The organization of the graph lets the data to be stored once and then interpreted in different ways based on relationships.</p>
<h3 id="ch11lev1sec1">11.1. What Is a Graph Database?</h3>
<p class="noindent">In the example graph in <a href="#ch11fig01">Figure 11.1</a>, we see a bunch of nodes related to each other. Nodes are entities that have properties, such as <code>name</code>. The node of <code>Martin</code> is actually a <strong>node</strong> that has <strong>property</strong> of <code>name</code> set to <code>Martin</code>.</p>
<div class="image"><a id="ch11fig01"/><img alt="Image" src="graphics/11fig01.jpg"/></div>
<p class="fig-caption">Figure 11.1. An example graph structure</p>
<p class="indent">We also see that edges have types, such as <code>likes</code>, <code>author</code>, and so on. These properties let us organize the nodes; for example, the nodes <code>Martin</code> and <code>Pramod</code> have an <strong>edge</strong> connecting them with a relationship type of <code>friend</code>. Edges can have multiple properties. We can assign a property of <code>since</code> on the <code>friend</code> relationship type between <code>Martin</code> and <code>Pramod</code>. Relationship types have directional significance; the <code>friend</code> relationship type is bidirectional but <code>likes</code> is not. When <code>Dawn likes NoSQL Distilled</code>, it does not automatically mean <code>NoSQL Distilled likes Dawn</code>.</p>
<p class="indent">Once we have a graph of these nodes and edges created, we can query the graph in many ways, such as “get all nodes employed by <code>Big Co</code> that <code>like NoSQL Distilled</code>.” A query on the graph is also known as <strong>traversing</strong> the graph. An advantage of the graph databases is that we can change the traversing requirements without having to change the nodes or edges. If we want to “get all nodes that <code>like NoSQL Distilled</code>,” we can do so without having to change the existing data or the model of the database, because we can traverse the graph any way we like.</p>
<p class="indent"><a id="page_112"/>Usually, when we store a graph-like structure in RDBMS, it’s for a single type of relationship (“who is my manager” is a common example). Adding another relationship to the mix usually means a lot of schema changes and data movement, which is not the case when we are using graph databases. Similarly, in relational databases we model the graph beforehand based on the <code>Traversal</code> we want; if the <code>Traversal</code> changes, the data will have to change.</p>
<p class="indent">In graph databases, traversing the joins or relationships is very fast. The relationship between nodes is not calculated at query time but is actually persisted as a relationship. Traversing persisted relationships is faster than calculating them for every query.</p>
<p class="indent">Nodes can have different types of relationships between them, allowing you to both represent relationships between the domain entities and to have secondary relationships for things like category, path, time-trees, quad-trees for spatial indexing, or linked lists for sorted access. Since there is no limit to the number and kind of relationships a node can have, all they can be represented in the same graph database.</p>
<h3 id="ch11lev1sec2"><a id="page_113"/>11.2. Features</h3>
<p class="noindent">There are many graph databases available, such as Neo4J <a href="bib01.html#bib_47">[Neo4J]</a>, Infinite Graph <a href="bib01.html#bib_37">[Infinite Graph]</a>, OrientDB <a href="bib01.html#bib_52">[OrientDB]</a>, or FlockDB <a href="bib01.html#bib_23">[FlockDB]</a> (which is a special case: a graph database that only supports single-depth relationships or adjacency lists, where you cannot traverse more than one level deep for relationships). We will take Neo4J as a representative of the graph database solutions to discuss how they work and how they can be used to solve application problems.</p>
<p class="indent">In Neo4J, creating a graph is as simple as creating two nodes and then creating a relationship. Let’s create two nodes, <code>Martin</code> and <code>Pramod</code>:</p>
<p class="codelink"><a href="images.html#p0133_01" id="p0133_01a">Click here to view code image</a></p>
<p class="programlisting">Node martin = graphDb.createNode();<br/>martin.setProperty("name", "Martin");<br/><br/>Node pramod = graphDb.createNode();<br/>pramod.setProperty("name", "Pramod");</p>
<p class="indent">We have assigned the <code>name</code> property of the two nodes the values of <code>Martin</code> and <code>Pramod</code>. Once we have more than one node, we can create a relationship:</p>
<p class="codelink"><a href="images.html#p0133_02" id="p0133_02a">Click here to view code image</a></p>
<p class="programlisting">martin.createRelationshipTo(pramod, FRIEND);<br/><br/>pramod.createRelationshipTo(martin, FRIEND);</p>
<p class="indent">We have to create relationship between the nodes in both directions, for the direction of the relationship matters: For example, a <code>product</code> node can be liked by <code>user</code> but the <code>product</code> cannot like the <code>user</code>. This directionality helps in designing a rich domain model (<a href="#ch11fig02">Figure 11.2</a>). Nodes know about <code>INCOMING</code> and <code>OUTGOING</code> relationships that are traversable both ways.</p>
<div class="image"><a id="ch11fig02"/><img alt="Image" height="515" src="graphics/11fig02.jpg" width="832"/></div>
<p class="fig-caption">Figure 11.2. Relationships with properties</p>
<p class="indent">Relationships are first-class citizens in graph databases; most of the value of graph databases is derived from the relationships. Relationships don’t only have a type, a start node, and an end node, but can have properties of their own. Using these properties on the relationships, we can add intelligence to the relationship—for example, since when did they become friends, what is the distance between the nodes, or what aspects are shared between the nodes. These properties on the relationships can be used to query the graph.</p>
<p class="indent">Since most of the power from the graph databases comes from the relationships and their properties, a lot of thought and design work is needed to model the relationships in the domain that we are trying to work with. Adding new relationship types is easy; changing existing nodes and their relationships is similar to data migration (“<a href="ch12.html#ch12lev2sec4">Migrations in Graph Databases</a>,” p. <a href="ch12.html#page_131">131</a>), because these changes will have to be done on each node and each relationship in the existing data.</p>
<h4 id="ch11lev2sec1"><a id="page_114"/>11.2.1. Consistency</h4>
<p class="noindent">Since graph databases are operating on connected nodes, most graph database solutions usually do not support distributing the nodes on different servers. There are some solutions, however, that support node distribution across a cluster of servers, such as Infinite Graph. Within a single server, data is always consistent, especially in Neo4J which is fully ACID-compliant. When running Neo4J in a cluster, a write to the master is eventually synchronized to the slaves, while slaves are always available for read. Writes to slaves are allowed and are immediately synchronized to the master; other slaves will not be synchronized immediately, though—they will have to wait for the data to propagate from the master.</p>
<p class="indent">Graph databases ensure consistency through transactions. They do not allow dangling relationships: The start node and end node always have to exist, and nodes can only be deleted if they don’t have any relationships attached to them.</p>
<h4 id="ch11lev2sec2">11.2.2. Transactions</h4>
<p class="noindent">Neo4J is ACID-compliant. Before changing any nodes or adding any relationships to existing nodes, we have to start a transaction. Without wrapping operations in transactions, we will get a <code>NotInTransactionException</code>. Read operations can be done without initiating a transaction.</p>
<p class="codelink"><a href="images.html#p0135_01" id="p0135_01a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_115"/>Transaction transaction = database.beginTx();<br/>try {<br/>    Node node = database.createNode();<br/>    node.setProperty("name", "NoSQL Distilled");<br/>    node.setProperty("published", "2012");<br/>    transaction.success();<br/>} finally {<br/>    transaction.finish();<br/>}</p>
<p class="indent">In the above code, we started a transaction on the database, then created a node and set properties on it. We marked the transaction as <code>success</code> and finally completed it by <code>finish</code>. A transaction has to be marked as <code>success</code>, otherwise Neo4J assumes that it was a failure and rolls it back when <code>finish</code> is issued. Setting <code>success</code> without issuing <code>finish</code> also does not commit the data to the database. This way of managing transactions has to be remembered when developing, as it differs from the standard way of doing transactions in an RDBMS.</p>
<h4 id="ch11lev2sec3">11.2.3. Availability</h4>
<p class="noindent">Neo4J, as of version 1.8, achieves high availability by providing for replicated slaves. These slaves can also handle writes: When they are written to, they synchronize the write to the current master, and the write is committed first at the master and then at the slave. Other slaves will eventually get the update. Other graph databases, such as Infinite Graph and FlockDB, provide for distributed storage of the nodes.</p>
<p class="indent">Neo4J uses the Apache ZooKeeper <a href="bib01.html#bib_68">[ZooKeeper]</a> to keep track of the last transaction IDs persisted on each slave node and the current master node. Once a server starts up, it communicates with ZooKeeper and finds out which server is the master. If the server is the first one to join the cluster, it becomes the master; when a master goes down, the cluster elects a master from the available nodes, thus providing high availability.</p>
<h4 id="ch11lev2sec4">11.2.4. Query Features</h4>
<p class="noindent">Graph databases are supported by query languages such as Gremlin <a href="bib01.html#bib_28">[Gremlin]</a>. Gremlin is a domain-specific language for traversing graphs; it can traverse all graph databases that implement the Blueprints <a href="bib01.html#bib_07">[Blueprints]</a> property graph. Neo4J also has the Cypher <a href="bib01.html#bib_16">[Cypher]</a> query language for querying the graph. Outside these query languages, Neo4J allows you to query the graph for properties of the nodes, traverse the graph, or navigate the nodes relationships using language bindings.</p>
<p class="indent">Properties of a node can be indexed using the indexing service. Similarly, properties of relationships or edges can be indexed, so a node or edge can be found by the value. Indexes should be queried to find the starting node to begin a traversal. Let’s look at searching for the node using node indexing.</p>
<p class="indent"><a id="page_116"/>If we have the graph shown in <a href="#ch11fig01">Figure 11.1</a>, we can index the nodes as they are added to the database, or we can index all the nodes later by iterating over them. We first need to create an index for the nodes using the <strong>IndexManager</strong>.</p>
<p class="codelink"><a href="images.html#p0136_01" id="p0136_01a">Click here to view code image</a></p>
<p class="programlisting">Index&lt;Node&gt; nodeIndex = graphDb.index().forNodes("nodes");</p>
<p class="indent">We are indexing the nodes for the <code>name</code> property. Neo4J uses Lucene <a href="bib01.html#bib_41">[Lucene]</a> as its indexing service. We will see later that we can also use the full-text search capability of Lucene. When new nodes are created, they can be added to the index.</p>
<p class="codelink"><a href="images.html#p0136_02" id="p0136_02a">Click here to view code image</a></p>
<p class="programlisting">Transaction transaction = graphDb.beginTx();<br/>try {<br/>    Index&lt;Node&gt; nodeIndex = graphDb.index().forNodes("nodes");<br/>    nodeIndex.add(martin, "name", martin.getProperty("name"));<br/>    nodeIndex.add(pramod, "name", pramod.getProperty("name"));<br/>    transaction.success();<br/>} finally {<br/>    transaction.finish();<br/>}</p>
<p class="indent">Adding nodes to the index is done inside the context of a transaction. Once the nodes are indexed, we can search them using the indexed property. If we search for the node with the name of <code>Barbara</code>, we would query the index for the property of <code>name</code> to have a value of <code>Barbara</code>.</p>
<p class="codelink"><a href="images.html#p0136_03" id="p0136_03a">Click here to view code image</a></p>
<p class="programlisting">Node node = nodeIndex.get("name", "Barbara").getSingle();</p>
<p class="indent">We get the node whose <code>name</code> is <code>Martin</code>; given the node, we can get all its relationships.</p>
<p class="codelink"><a href="images.html#p0136_04" id="p0136_04a">Click here to view code image</a></p>
<p class="programlisting">Node martin = nodeIndex.get("name", "Martin").getSingle();<br/>allRelationships = martin.getRelationships();</p>
<p class="indent">We can get both <code>INCOMING</code> or <code>OUTGOING</code> relationships.</p>
<p class="codelink"><a href="images.html#p0136_05" id="p0136_05a">Click here to view code image</a></p>
<p class="programlisting">incomingRelations = martin.getRelationships(Direction.INCOMING);</p>
<p class="indent">We can also apply directional filters on the queries when querying for a relationship. With the graph in <a href="#ch11fig01">Figure 11.1</a>, if we want to find all people who like <code>NoSQL Distilled</code>, we can find the <code>NoSQL Distilled</code> node and then get its relationships with <code>Direction.INCOMING</code>. At this point we can also add the type of relationship to the query filter, since we are looking only for nodes that <code>LIKE NoSQL Distilled</code>.</p>
<p class="codelink"><a href="images.html#p0136_06" id="p0136_06a">Click here to view code image</a></p>
<p class="programlisting">Node nosqlDistilled = nodeIndex.get("name",<br/>                            "NoSQL Distilled").getSingle();<br/>relationships = nosqlDistilled.getRelationships(INCOMING, LIKES);<br/>for (Relationship relationship : relationships) {<br/>likesNoSQLDistilled.add(relationship.getStartNode());<br/>}</p>
<p class="indent"><a id="page_117"/>Finding nodes and their immediate relations is easy, but this can also be achieved in RDBMS databases. Graph databases are really powerful when you want to traverse the graphs at any depth and specify a starting node for the traversal. This is especially useful when you are trying to find nodes that are related to the starting node at more than one level down. As the depth of the graph increases, it makes more sense to traverse the relationships by using a <code>Traverser</code> where you can specify that you are looking for <code>INCOMING</code>, <code>OUTGOING</code>, or <code>BOTH</code> types of relationships. You can also make the traverser go top-down or sideways on the graph by using <code>Order</code> values of <code>BREADTH_FIRST</code> or <code>DEPTH_FIRST</code>. The traversal has to start at some node—in this example, we try to find all the nodes at any depth that are related as a <code>FRIEND</code> with <code>Barbara</code>:</p>
<p class="codelink"><a href="images.html#p0137_01" id="p0137_01a">Click here to view code image</a></p>
<p class="programlisting">Node barbara = nodeIndex.get("name", "Barbara").getSingle();<br/><br/>Traverser friendsTraverser = barbara.traverse(Order.BREADTH_FIRST,<br/>    StopEvaluator.END_OF_GRAPH,<br/>    ReturnableEvaluator.ALL_BUT_START_NODE,<br/>    EdgeType.FRIEND,<br/>    Direction.OUTGOING);</p>
<p class="indent">The <code>friendsTraverser</code> provides us a way to find all the nodes that are related to <code>Barbara</code> where the relationship type is <code>FRIEND</code>. The nodes can be at any depth—friend of a friend at any level—allowing you to explore tree structures.</p>
<p class="indent">One of the good features of graph databases is finding paths between two nodes—determining if there are multiple paths, finding all of the paths or the shortest path. In the graph in <a href="#ch11fig01">Figure 11.1</a>, we know that <code>Barbara</code> is connected to <code>Jill</code> by two distinct paths; to find all these paths and the distance between <code>Barbara</code> and <code>Jill</code> along those different paths, we can use</p>
<p class="codelink"><a href="images.html#p0137_02" id="p0137_02a">Click here to view code image</a></p>
<p class="programlisting">Node barbara = nodeIndex.get("name", "Barbara").getSingle();<br/>Node jill = nodeIndex.get("name", "Jill").getSingle();<br/>PathFinder&lt;Path&gt; finder = GraphAlgoFactory.allPaths(<br/>        Traversal.expanderForTypes(FRIEND,Direction.OUTGOING)<br/>                                  ,MAX_DEPTH);<br/>Iterable&lt;Path&gt; paths = finder.findAllPaths(barbara, jill);</p>
<p class="indent">This feature is used in social networks to show relationships between any two nodes. To find all the paths and the distance between the nodes for each path, we first get a list of distinct paths between the two nodes. The length of each path is the <strong>number of hops</strong> on the graph needed to reach the destination node from the start node. Often, you need to get the shortest path between two nodes; of the two paths from <code>Barbara</code> to <code>Jill</code>, the shortest path can be found by using</p>
<p class="codelink"><a href="images.html#p0137_03" id="p0137_03a">Click here to view code image</a></p>
<p class="programlisting">PathFinder&lt;Path&gt; finder = GraphAlgoFactory.shortestPath(<br/>        Traversal.expanderForTypes(FRIEND, Direction.OUTGOING)<br/>                                   , MAX_DEPTH);<br/>Iterable&lt;Path&gt; paths = finder.findAllPaths(barbara, jill);</p>
<p class="indent"><a id="page_118"/>Many other graph algorithms can be applied to the graph at hand, such as Dijkstra’s algorithm <a href="bib01.html#bib_21">[Dijkstra’s]</a> for finding the shortest or cheapest path between nodes.</p>
<p class="codelink"><a href="images.html#p0138_01" id="p0138_01a">Click here to view code image</a></p>
<p class="programlisting">START beginingNode = (beginning node specification)<br/>MATCH (relationship, pattern matches)<br/>WHERE (filtering condition: on data in nodes and relationships)<br/>RETURN (What to return: nodes, relationships, properties)<br/>ORDER BY (properties to order by)<br/>SKIP (nodes to skip from top)<br/>LIMIT (limit results)</p>
<p class="indent">Neo4J also provides the <strong>Cypher</strong> query language to query the graph. Cypher needs a node to <code>START</code> the query. The start node can be identified by its node ID, a list of node IDs, or index lookups. Cypher uses the <code>MATCH</code> keyword for matching patterns in relationships; the <code>WHERE</code> keyword filters the properties on a node or relationship. The <code>RETURN</code> keyword specifies what gets returned by the query—nodes, relationships, or fields on the nodes or relationships.</p>
<p class="indent">Cypher also provides methods to <code>ORDER</code>, <code>AGGREGATE</code>, <code>SKIP</code>, and <code>LIMIT</code> the data. In <a href="#ch11fig02">Figure 11.2</a>, we find all nodes connected to <code>Barbara</code>, either incoming or outgoing, by using the <code>--</code>.</p>
<p class="codelink"><a href="images.html#p0138_02" id="p0138_02a">Click here to view code image</a></p>
<p class="programlisting"><a id="page_119"/>START barbara = node:nodeIndex(name = "Barbara")<br/>MATCH (barbara)--(connected_node)<br/>RETURN connected_node</p>
<p class="indent">When interested in directional significance, we can use</p>
<p class="programlisting">MATCH (barbara)&lt;--(connected_node)</p>
<p class="noindent">for incoming relationships or</p>
<p class="programlisting">MATCH (barbara)--&gt;(connected_node)</p>
<p class="noindent">for outgoing relationships. Match can also be done on specific relationships using the <code>:RELATIONSHIP_TYPE</code> convention and returning the required fields or nodes.</p>
<p class="codelink"><a href="images.html#p0138_03" id="p0138_03a">Click here to view code image</a></p>
<p class="programlisting">START barbara = node:nodeIndex(name = "Barbara")<br/>MATCH (barbara)-[:FRIEND]-&gt;(friend_node)<br/>RETURN friend_node.name,friend_node.location</p>
<p class="indent">We start with <code>Barbara</code>, find all outgoing relationships with the type of <code>FRIEND</code>, and return the friends’ names. The relationship type query only works for the depth of one level; we can make it work for greater depths and find out the depth of each of the result nodes.</p>
<p class="codelink"><a href="images.html#p0139_01" id="p0139_01a">Click here to view code image</a></p>
<p class="programlisting">START barbara=node:nodeIndex(name = "Barbara")<br/>MATCH path = barbara-[:FRIEND*1..3]-&gt;end_node<br/>RETURN barbara.name,end_node.name, length(path)</p>
<p class="indent">Similarly, we can query for relationships where a particular relationship property exists. We can also filter on the properties of relationships and query if a property exists or not.</p>
<p class="codelink"><a href="images.html#p0139_02" id="p0139_02a">Click here to view code image</a></p>
<p class="programlisting">START barbara = node:nodeIndex(name = "Barbara")<br/>MATCH (barbara)-[relation]-&gt;(related_node)<br/>WHERE type(relation) = 'FRIEND' AND relation.share<br/>RETURN related_node.name, relation.since</p>
<p class="indent">There are many other query features in the Cypher language that can be used to query database graphs.</p>
<h4 id="ch11lev2sec5">11.2.5. Scaling</h4>
<p class="noindent">In NoSQL databases, one of the commonly used scaling techniques is sharding, where data is split and distributed across different servers. With graph databases, sharding is difficult, as graph databases are not aggregate-oriented but relationship-oriented. Since any given node can be related to any other node, storing related nodes on the same server is better for graph traversal. Traversing a graph when the nodes are on different machines is not good for performance. Knowing this limitation of the graph databases, we can still scale them using some common techniques described by Jim Webber <a href="bib01.html#bib_67">[Webber Neo4J Scaling]</a>.</p>
<p class="indent">Generally speaking, there are three ways to scale graph databases. Since machines now can come with lots of RAM, we can add enough RAM to the server so that the working set of nodes and relationships is held entirely in memory. This technique is only helpful if the dataset that we are working with will fit in a realistic amount of RAM.</p>
<p class="indent">We can improve the read scaling of the database by adding more slaves with read-only access to the data, with all the writes going to the master. This pattern of writing once and reading from many servers is a proven technique in MySQL clusters and is really useful when the dataset is large enough to not fit in a single machine’s RAM, but small enough to be replicated across multiple machines. Slaves can also contribute to availability and read-scaling, as they can be configured to never become a master, remaining always read-only.</p>
<p class="indent">When the dataset size makes replication impractical, we can shard (see the “<a href="ch04.html#ch04lev1sec2">Sharding</a>” section on p. <a href="ch04.html#page_38">38</a>) the data from the application side using domain-specific knowledge. For example, nodes that relate to the North America can be created on one server while the nodes that relate to Asia on another. This application-level sharding needs to understand that nodes are stored on physically different databases (<a href="#ch11fig03">Figure 11.3</a>).</p>
<div class="image"><a id="page_120"/><a id="ch11fig03"/><img alt="Image" src="graphics/11fig03.jpg"/></div>
<p class="fig-caption">Figure 11.3. Application-level sharding of nodes</p>
<h3 id="ch11lev1sec3">11.3. Suitable Use Cases</h3>
<p class="noindent">Let’s look at some suitable use cases for graph databases.</p>
<h4 id="ch11lev2sec6">11.3.1. Connected Data</h4>
<p class="noindent">Social networks are where graph databases can be deployed and used very effectively. These social graphs don’t have to be only of the friend kind; for example, they can represent employees, their knowledge, and where they worked with other employees on different projects. Any link-rich domain is well suited for graph databases.</p>
<p class="indent">If you have relationships between domain entities from different domains (such as social, spatial, commerce) in a single database, you can make these relationships more valuable by providing the ability to traverse across domains.</p>
<h4 id="ch11lev2sec7">11.3.2. Routing, Dispatch, and Location-Based Services</h4>
<p class="noindent">Every location or address that has a delivery is a node, and all the nodes where the delivery has to be made by the delivery person can be modeled as a graph of nodes. Relationships between nodes can have the property of distance, thus <a id="page_121"/>allowing you to deliver the goods in an efficient manner. Distance and location properties can also be used in graphs of places of interest, so that your application can provide recommendations of good restaurants or entertainment options nearby. You can also create nodes for your points of sales, such as bookstores or restaurants, and notify the users when they are close to any of the nodes to provide location-based services.</p>
<h4 id="ch11lev2sec8">11.3.3. Recommendation Engines</h4>
<p class="noindent">As nodes and relationships are created in the system, they can be used to make recommendations like “your friends also bought this product” or “when invoicing this item, these other items are usually invoiced.” Or, it can be used to make recommendations to travelers mentioning that when other visitors come to Barcelona they usually visit Antonio Gaudi’s creations.</p>
<p class="indent">An interesting side effect of using the graph databases for recommendations is that as the data size grows, the number of nodes and relationships available to make the recommendations quickly increases. The same data can also be used to mine information—for example, which products are always bought together, or which items are always invoiced together; alerts can be raised when these conditions are not met. Like other recommendation engines, graph databases can be used to search for patterns in relationships to detect fraud in transactions.</p>
<h3 id="ch11lev1sec4">11.4. When Not to Use</h3>
<p class="noindent">In some situations, graph databases may not appropriate. When you want to update all or a subset of entities—for example, in an analytics solution where all entities may need to be updated with a changed property—graph databases may not be optimal since changing a property on all the nodes is not a straightforward operation. Even if the data model works for the problem domain, some databases may be unable to handle lots of data, especially in global graph operations (those involving the whole graph).</p>
</body>
</html>